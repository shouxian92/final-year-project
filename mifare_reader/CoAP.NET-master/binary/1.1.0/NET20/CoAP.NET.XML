<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CoAP.NET</name>
    </assembly>
    <members>
        <member name="T:CoAP.WebLink">
            <summary>
            This class can be used to programmatically browse a remote CoAP endoint.
            </summary>
        </member>
        <member name="M:CoAP.WebLink.#ctor(System.String)">
            <summary>
            Instantiates.
            </summary>
            <param name="uri">the uri of this resource.</param>
        </member>
        <member name="M:CoAP.WebLink.CompareTo(CoAP.WebLink)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.WebLink.ToString">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.WebLink.Uri">
            <summary>
            Gets the uri of this resource.
            </summary>
        </member>
        <member name="P:CoAP.WebLink.Attributes">
            <summary>
            Gets the attributes of this resource.
            </summary>
        </member>
        <member name="T:CoAP.Util.WaitFuture`2">
            <summary>
            Provides methods to wait for a response of a request.
            </summary>
            <typeparam name="TRequest">the type of the request</typeparam>
            <typeparam name="TResponse">the type of the response</typeparam>
        </member>
        <member name="M:CoAP.Util.WaitFuture`2.#ctor(`0)">
            <summary>
            Instantiates.
            </summary>
            <param name="request">the request to wait</param>
        </member>
        <member name="M:CoAP.Util.WaitFuture`2.Wait">
            <summary>
            Waits for response.
            </summary>
        </member>
        <member name="M:CoAP.Util.WaitFuture`2.Wait(System.Int32)">
            <summary>
            Waits for response for the given time.
            </summary>
        </member>
        <member name="M:CoAP.Util.WaitFuture`2.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Util.WaitFuture`2.WaitAll(System.Collections.Generic.IEnumerable{CoAP.Util.WaitFuture{`0,`1}})">
            <summary>
            Waits for all response.
            </summary>
        </member>
        <member name="M:CoAP.Util.WaitFuture`2.WaitAll(System.Collections.Generic.IEnumerable{CoAP.Util.WaitFuture{`0,`1}},System.Int32)">
            <summary>
            Waits for all response for the given time.
            </summary>
        </member>
        <member name="P:CoAP.Util.WaitFuture`2.Request">
            <summary>
            Gets the request.
            </summary>
        </member>
        <member name="P:CoAP.Util.WaitFuture`2.Response">
            <summary>
            Gets the response.
            </summary>
        </member>
        <member name="T:CoAP.Stack.TokenLayer">
            <summary>
            Doesn't do much yet except for setting a simple token. Notice that empty
            tokens must be represented as byte array of length 0 (not null).
            </summary>
        </member>
        <member name="T:CoAP.Stack.AbstractLayer">
            <summary>
            A partial implementation of a layer.
            </summary>
        </member>
        <member name="T:CoAP.Stack.ILayer">
            <summary>
            Represents a layer in the stack.
            </summary>
        </member>
        <member name="M:CoAP.Stack.ILayer.SendRequest(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.Request)">
            <summary>
            Filters a request sending event.
            </summary>
            <param name="nextLayer">the next layer</param>
            <param name="exchange">the exchange associated</param>
            <param name="request">the request to send</param>
        </member>
        <member name="M:CoAP.Stack.ILayer.SendResponse(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.Response)">
            <summary>
            Filters a response sending event.
            </summary>
            <param name="nextLayer">the next layer</param>
            <param name="exchange">the exchange associated</param>
            <param name="response">the response to send</param>
        </member>
        <member name="M:CoAP.Stack.ILayer.SendEmptyMessage(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.EmptyMessage)">
            <summary>
            Filters an empty message sending event.
            </summary>
            <param name="nextLayer">the next layer</param>
            <param name="exchange">the exchange associated</param>
            <param name="message">the empty message to send</param>
        </member>
        <member name="M:CoAP.Stack.ILayer.ReceiveRequest(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.Request)">
            <summary>
            Filters a request receiving event.
            </summary>
            <param name="nextLayer">the next layer</param>
            <param name="exchange">the exchange associated</param>
            <param name="request">the request to receive</param>
        </member>
        <member name="M:CoAP.Stack.ILayer.ReceiveResponse(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.Response)">
            <summary>
            Filters a response receiving event.
            </summary>
            <param name="nextLayer">the next layer</param>
            <param name="exchange">the exchange associated</param>
            <param name="response">the response to receive</param>
        </member>
        <member name="M:CoAP.Stack.ILayer.ReceiveEmptyMessage(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.EmptyMessage)">
            <summary>
            Filters an empty message receiving event.
            </summary>
            <param name="nextLayer">the next layer</param>
            <param name="exchange">the exchange associated</param>
            <param name="message">the empty message to receive</param>
        </member>
        <member name="P:CoAP.Stack.ILayer.Executor">
            <summary>
            Gets or set the executor to schedule tasks.
            </summary>
        </member>
        <member name="M:CoAP.Stack.AbstractLayer.SendRequest(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.Request)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.AbstractLayer.SendResponse(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.Response)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.AbstractLayer.SendEmptyMessage(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.EmptyMessage)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.AbstractLayer.ReceiveRequest(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.Request)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.AbstractLayer.ReceiveResponse(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.Response)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.AbstractLayer.ReceiveEmptyMessage(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.EmptyMessage)">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Stack.AbstractLayer.Executor">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.TokenLayer.#ctor(CoAP.ICoapConfig)">
            <summary>
            Constructs a new token layer.
            </summary>
        </member>
        <member name="M:CoAP.Stack.TokenLayer.SendRequest(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.Request)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.TokenLayer.SendResponse(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.Response)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.TokenLayer.ReceiveRequest(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.Request)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.TokenLayer.ReceiveResponse(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.Response)">
            <inheritdoc/>
        </member>
        <member name="T:CoAP.Stack.LayerStack">
            <summary>
            Stack of layers.
            </summary>
        </member>
        <member name="T:CoAP.Stack.Chain`3">
            <summary>
            Abstract implementation of <see cref="T:CoAP.Stack.IChain`2"/>
            </summary>
            <typeparam name="TChain">the actual type of the chain</typeparam>
            <typeparam name="TFilter">the type of filters</typeparam>
            <typeparam name="TNextFilter">the type of next filters</typeparam>
        </member>
        <member name="T:CoAP.Stack.IChain`2">
            <summary>
            Represents a chain of filters.
            </summary>
            <typeparam name="TFilter">the type of filters</typeparam>
            <typeparam name="TNextFilter">the type of next filters</typeparam>
        </member>
        <member name="M:CoAP.Stack.IChain`2.GetEntry(System.String)">
            <summary>
            Gets the <see cref="T:CoAP.Stack.IEntry`2"/> with the specified <paramref name="name"/> in this chain.
            </summary>
            <param name="name">the filter's name we are looking for</param>
            <returns>the <see cref="T:CoAP.Stack.IEntry`2"/> with the given name, or null if not found</returns>
        </member>
        <member name="M:CoAP.Stack.IChain`2.GetEntry(`0)">
            <summary>
            Gets the <see cref="T:CoAP.Stack.IEntry`2"/> with the specified <paramref name="filter"/> in this chain.
            </summary>
            <param name="filter">the filter we are looking for</param>
            <returns>the <see cref="T:CoAP.Stack.IEntry`2"/>, or null if not found</returns>
        </member>
        <member name="M:CoAP.Stack.IChain`2.GetEntry(System.Type)">
            <summary>
            Gets the <see cref="T:CoAP.Stack.IEntry`2"/> with the specified <paramref name="filterType"/> in this chain.
            </summary>
            <remarks>If there's more than one filter with the specified type, the first match will be chosen.</remarks>
            <param name="filterType">the type of filter we are looking for</param>
            <returns>the <see cref="T:CoAP.Stack.IEntry`2"/>, or null if not found</returns>
        </member>
        <member name="M:CoAP.Stack.IChain`2.Get(System.String)">
            <summary>
            Gets the <typeparamref name="TFilter"/> with the specified <paramref name="name"/> in this chain.
            </summary>
            <param name="name">the filter's name</param>
            <returns>the <typeparamref name="TFilter"/>, or null if not found</returns>
        </member>
        <member name="M:CoAP.Stack.IChain`2.GetNextFilter(System.String)">
            <summary>
            Gets the <typeparamref name="TNextFilter"/> of the <typeparamref name="TFilter"/>
            with the specified <paramref name="name"/> in this chain.
            </summary>
            <param name="name">the filter's name</param>
            <returns>the <typeparamref name="TNextFilter"/>, or null if not found</returns>
        </member>
        <member name="M:CoAP.Stack.IChain`2.GetNextFilter(`0)">
            <summary>
            Gets the <typeparamref name="TNextFilter"/> of the <typeparamref name="TFilter"/>
            with the specified <paramref name="filter"/> in this chain.
            </summary>
            <param name="filter">the filter</param>
            <returns>the <typeparamref name="TNextFilter"/>, or null if not found</returns>
        </member>
        <member name="M:CoAP.Stack.IChain`2.GetNextFilter(System.Type)">
            <summary>
            Gets the <typeparamref name="TNextFilter"/> of the <typeparamref name="TFilter"/>
            with the specified <paramref name="filterType"/> in this chain.
            </summary>
            <remarks>If there's more than one filter with the specified type, the first match will be chosen.</remarks>
            <param name="filterType">the type of filter</param>
            <returns>the <typeparamref name="TNextFilter"/>, or null if not found</returns>
        </member>
        <member name="M:CoAP.Stack.IChain`2.GetAll">
            <summary>
            Gets all <see cref="T:CoAP.Stack.IEntry`2"/>s in this chain.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CoAP.Stack.IChain`2.Contains(System.String)">
            <summary>
            Checks if this chain contains a filter with the specified <paramref name="name"/>.
            </summary>
            <param name="name">the filter's name</param>
            <returns>true if this chain contains a filter with the specified <paramref name="name"/></returns>
        </member>
        <member name="M:CoAP.Stack.IChain`2.Contains(`0)">
            <summary>
            Checks if this chain contains the specified <paramref name="filter"/>.
            </summary>
            <param name="filter">the filter</param>
            <returns>true if this chain contains the specified <paramref name="filter"/></returns>
        </member>
        <member name="M:CoAP.Stack.IChain`2.Contains(System.Type)">
            <summary>
            Checks if this chain contains a filter with the specified <paramref name="filterType"/>.
            </summary>
            <param name="filterType">the filter's type</param>
            <returns>true if this chain contains a filter with the specified <paramref name="filterType"/></returns>
        </member>
        <member name="M:CoAP.Stack.IChain`2.AddFirst(System.String,`0)">
            <summary>
            Adds the specified filter with the specified name at the beginning of this chain.
            </summary>
            <param name="name">the filter's name</param>
            <param name="filter">the filter to add</param>
        </member>
        <member name="M:CoAP.Stack.IChain`2.AddLast(System.String,`0)">
            <summary>
            Adds the specified filter with the specified name at the end of this chain.
            </summary>
            <param name="name">the filter's name</param>
            <param name="filter">the filter to add</param>
        </member>
        <member name="M:CoAP.Stack.IChain`2.AddBefore(System.String,System.String,`0)">
            <summary>
            Adds the specified filter with the specified name just before the filter whose name is
            <paramref name="baseName"/> in this chain.
            </summary>
            <param name="baseName">the targeted filter's name</param>
            <param name="name">the filter's name</param>
            <param name="filter">the filter to add</param>
        </member>
        <member name="M:CoAP.Stack.IChain`2.AddAfter(System.String,System.String,`0)">
            <summary>
            Adds the specified filter with the specified name just after the filter whose name is
            <paramref name="baseName"/> in this chain.
            </summary>
            <param name="baseName">the targeted filter's name</param>
            <param name="name">the filter's name</param>
            <param name="filter">the filter to add</param>
        </member>
        <member name="M:CoAP.Stack.IChain`2.Replace(System.String,`0)">
            <summary>
            Replace the filter with the specified name with the specified new filter.
            </summary>
            <param name="name">the name of the filter to replace</param>
            <param name="newFilter">the new filter</param>
            <returns>the old filter</returns>
        </member>
        <member name="M:CoAP.Stack.IChain`2.Replace(`0,`0)">
            <summary>
            Replace the specified filter with the specified new filter.
            </summary>
            <param name="oldFilter">the filter to replace</param>
            <param name="newFilter">the new filter</param>
        </member>
        <member name="M:CoAP.Stack.IChain`2.Remove(System.String)">
            <summary>
            Removes the filter with the specified name from this chain.
            </summary>
            <param name="name">the name of the filter to remove</param>
            <returns>the removed filter</returns>
        </member>
        <member name="M:CoAP.Stack.IChain`2.Remove(`0)">
            <summary>
            Removes the specified filter.
            </summary>
            <param name="filter">the filter to remove</param>
        </member>
        <member name="M:CoAP.Stack.IChain`2.Clear">
            <summary>
            Removes all filters added to this chain.
            </summary>
        </member>
        <member name="M:CoAP.Stack.Chain`3.#ctor(CoAP.Func{CoAP.Stack.Chain{`0,`1,`2}.Entry,`2},CoAP.Func{`1},CoAP.Func{`1})">
            <summary>
            Instantiates.
            </summary>
            <param name="nextFilterFactory">the factory to create <typeparamref name="TNextFilter"/>s by (entry)</param>
            <param name="headFilterFactory">the factory to create the head <typeparamref name="TFilter"/></param>
            <param name="tailFilterFactory">the factory to create the tail <typeparamref name="TFilter"/></param>
        </member>
        <member name="M:CoAP.Stack.Chain`3.#ctor(CoAP.Func{`0,CoAP.Stack.Chain{`0,`1,`2}.Entry,CoAP.Stack.Chain{`0,`1,`2}.Entry,System.String,`1,CoAP.Stack.Chain{`0,`1,`2}.Entry},CoAP.Func{`1},CoAP.Func{`1})">
            <summary>
            Instantiates.
            </summary>
            <param name="entryFactory">the factory to create entries by (chain, prev, next, name, filter)</param>
            <param name="headFilterFactory">the factory to create the head <typeparamref name="TFilter"/></param>
            <param name="tailFilterFactory">the factory to create the tail <typeparamref name="TFilter"/></param>
        </member>
        <member name="M:CoAP.Stack.Chain`3.#ctor(CoAP.Func{`0,CoAP.Stack.Chain{`0,`1,`2}.Entry,CoAP.Stack.Chain{`0,`1,`2}.Entry,System.String,`1,CoAP.Stack.Chain{`0,`1,`2}.Entry},CoAP.Func{`1},CoAP.Func{`1},CoAP.Func{`1,`1,System.Boolean})">
            <summary>
            Instantiates.
            </summary>
            <param name="entryFactory">the factory to create entries by (chain, prev, next, name, filter)</param>
            <param name="headFilterFactory">the factory to create the head <typeparamref name="TFilter"/></param>
            <param name="tailFilterFactory">the factory to create the tail <typeparamref name="TFilter"/></param>
            <param name="equalsFunc">the function to check equality between two <typeparamref name="TFilter"/>s</param>
        </member>
        <member name="M:CoAP.Stack.Chain`3.GetEntry(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.Get(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.GetEntry(`1)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.GetEntry(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.GetNextFilter(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.GetNextFilter(`1)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.GetNextFilter(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.GetAll">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.Contains(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.Contains(`1)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.Contains(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.AddFirst(System.String,`1)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.AddLast(System.String,`1)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.AddBefore(System.String,System.String,`1)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.AddAfter(System.String,System.String,`1)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.Replace(System.String,`1)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.Replace(`1,`1)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.Remove(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.Remove(`1)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.Clear">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.Deregister0(CoAP.Stack.Chain{`0,`1,`2}.Entry)">
            <summary>
            Deregister an entry from this chain.
            </summary>
        </member>
        <member name="M:CoAP.Stack.Chain`3.OnPreAdd(CoAP.Stack.Chain{`0,`1,`2}.Entry)">
            <summary>
            Fires before the entry is added to this chain.
            </summary>
        </member>
        <member name="M:CoAP.Stack.Chain`3.OnPostAdd(CoAP.Stack.Chain{`0,`1,`2}.Entry)">
            <summary>
            Fires after the entry is added to this chain.
            </summary>
        </member>
        <member name="M:CoAP.Stack.Chain`3.OnPreRemove(CoAP.Stack.Chain{`0,`1,`2}.Entry)">
            <summary>
            Fires before the entry is removed to this chain.
            </summary>
        </member>
        <member name="M:CoAP.Stack.Chain`3.OnPostRemove(CoAP.Stack.Chain{`0,`1,`2}.Entry)">
            <summary>
            Fires after the entry is removed to this chain.
            </summary>
        </member>
        <member name="P:CoAP.Stack.Chain`3.Head">
            <summary>
            Head of this chain.
            </summary>
        </member>
        <member name="P:CoAP.Stack.Chain`3.Tail">
            <summary>
            Tail of this chain.
            </summary>
        </member>
        <member name="T:CoAP.Stack.Chain`3.Entry">
            <summary>
            Represents an entry of filter in the chain.
            </summary>
        </member>
        <member name="T:CoAP.Stack.IEntry`2">
            <summary>
            Represents a name-filter pair that an <see cref="T:CoAP.Stack.IChain`2"/> contains.
            </summary>
        </member>
        <member name="M:CoAP.Stack.IEntry`2.AddBefore(System.String,`0)">
            <summary>
            Adds the specified filter with the specified name just before this entry.
            </summary>
        </member>
        <member name="M:CoAP.Stack.IEntry`2.AddAfter(System.String,`0)">
            <summary>
            Adds the specified filter with the specified name just after this entry.
            </summary>
        </member>
        <member name="M:CoAP.Stack.IEntry`2.Replace(`0)">
            <summary>
            Replace the filter of this entry with the specified new filter.
            </summary>
        </member>
        <member name="M:CoAP.Stack.IEntry`2.Remove">
            <summary>
            Removes this entry from the chain it belongs to.
            </summary>
        </member>
        <member name="P:CoAP.Stack.IEntry`2.Name">
            <summary>
            Gets the name of the filter.
            </summary>
        </member>
        <member name="P:CoAP.Stack.IEntry`2.Filter">
            <summary>
            Gets the filter.
            </summary>
        </member>
        <member name="P:CoAP.Stack.IEntry`2.NextFilter">
            <summary>
            Gets the <typeparamref name="TNextFilter"/> of the filter.
            </summary>
        </member>
        <member name="M:CoAP.Stack.Chain`3.Entry.#ctor(`0,CoAP.Stack.Chain{`0,`1,`2}.Entry,CoAP.Stack.Chain{`0,`1,`2}.Entry,System.String,`1,CoAP.Func{CoAP.Stack.Chain{`0,`1,`2}.Entry,`2})">
            <summary>
            Instantiates.
            </summary>
            <param name="chain">the chain this entry belongs to</param>
            <param name="prevEntry">the previous one</param>
            <param name="nextEntry">the next one</param>
            <param name="name">the name of this entry</param>
            <param name="filter">the associated <typeparamref name="TFilter"/></param>
            <param name="nextFilterFactory">the factory to create <typeparamref name="TNextFilter"/> by (entry)</param>
        </member>
        <member name="M:CoAP.Stack.Chain`3.Entry.AddBefore(System.String,`1)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.Entry.AddAfter(System.String,`1)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.Entry.Replace(`1)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.Entry.Remove">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.Chain`3.Entry.ToString">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Stack.Chain`3.Entry.Name">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Stack.Chain`3.Entry.Filter">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Stack.Chain`3.Entry.NextFilter">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Stack.Chain`3.Entry.Chain">
            <summary>
            Gets the chain this entry belongs to.
            </summary>
        </member>
        <member name="P:CoAP.Stack.Chain`3.Entry.PrevEntry">
            <summary>
            Gets the previous entry in the chain.
            </summary>
        </member>
        <member name="P:CoAP.Stack.Chain`3.Entry.NextEntry">
            <summary>
            Gets the next entry in the chain.
            </summary>
        </member>
        <member name="M:CoAP.Stack.LayerStack.#ctor">
            <summary>
            Instantiates.
            </summary>
        </member>
        <member name="M:CoAP.Stack.LayerStack.SendRequest(CoAP.Request)">
            <summary>
            Sends a request into the layer stack.
            </summary>
            <param name="request">the request to send</param>
        </member>
        <member name="M:CoAP.Stack.LayerStack.SendResponse(CoAP.Net.Exchange,CoAP.Response)">
            <summary>
            Sends a response into the layer stack.
            </summary>
            <param name="exchange">the exchange associated</param>
            <param name="response">the response to send</param>
        </member>
        <member name="M:CoAP.Stack.LayerStack.SendEmptyMessage(CoAP.Net.Exchange,CoAP.EmptyMessage)">
            <summary>
            Sends an empty message into the layer stack.
            </summary>
            <param name="exchange">the exchange associated</param>
            <param name="message">the message to send</param>
        </member>
        <member name="M:CoAP.Stack.LayerStack.ReceiveRequest(CoAP.Net.Exchange,CoAP.Request)">
            <summary>
            Receives a request into the layer stack.
            </summary>
            <param name="exchange">the exchange associated</param>
            <param name="request">the response to receive</param>
        </member>
        <member name="M:CoAP.Stack.LayerStack.ReceiveResponse(CoAP.Net.Exchange,CoAP.Response)">
            <summary>
            Receives a response into the layer stack.
            </summary>
            <param name="exchange">the exchange associated</param>
            <param name="response">the response to receive</param>
        </member>
        <member name="M:CoAP.Stack.LayerStack.ReceiveEmptyMessage(CoAP.Net.Exchange,CoAP.EmptyMessage)">
            <summary>
            Receives an empty message into the layer stack.
            </summary>
            <param name="exchange">the exchange associated</param>
            <param name="message">the message to receive</param>
        </member>
        <member name="T:CoAP.Stack.INextLayer">
            <summary>
            Represent a next layer in the stack.
            </summary>
        </member>
        <member name="M:CoAP.Stack.INextLayer.SendRequest(CoAP.Net.Exchange,CoAP.Request)">
            <summary>
            Sends a request to next layer.
            </summary>
        </member>
        <member name="M:CoAP.Stack.INextLayer.SendResponse(CoAP.Net.Exchange,CoAP.Response)">
            <summary>
            Sends a response to next layer.
            </summary>
        </member>
        <member name="M:CoAP.Stack.INextLayer.SendEmptyMessage(CoAP.Net.Exchange,CoAP.EmptyMessage)">
            <summary>
            Sends an empty message to next layer.
            </summary>
        </member>
        <member name="M:CoAP.Stack.INextLayer.ReceiveRequest(CoAP.Net.Exchange,CoAP.Request)">
            <summary>
            Receives a request to next layer.
            </summary>
        </member>
        <member name="M:CoAP.Stack.INextLayer.ReceiveResponse(CoAP.Net.Exchange,CoAP.Response)">
            <summary>
            Receives a response to next layer.
            </summary>
        </member>
        <member name="M:CoAP.Stack.INextLayer.ReceiveEmptyMessage(CoAP.Net.Exchange,CoAP.EmptyMessage)">
            <summary>
            Receives an empty message to next layer.
            </summary>
        </member>
        <member name="T:CoAP.Option">
            <summary>
            This class describes the options of the CoAP messages.
            </summary>
        </member>
        <member name="F:CoAP.Option._valueBytes">
            <summary>
            NOTE: value bytes in network byte order (big-endian)
            </summary>
        </member>
        <member name="M:CoAP.Option.#ctor(CoAP.OptionType)">
            <summary>
            Initializes an option.
            </summary>
            <param name="type">The type of the option</param>
        </member>
        <member name="M:CoAP.Option.ToString">
            <summary>
            Returns a human-readable string representation of the option's value.
            </summary>
        </member>
        <member name="M:CoAP.Option.GetHashCode">
            <summary>
            Gets the hash code of this object
            </summary>
            <returns>The hash code</returns>
        </member>
        <member name="M:CoAP.Option.Create(CoAP.OptionType)">
            <summary>
            Creates an option.
            </summary>
            <param name="type">The type of the option</param>
            <returns>The new option</returns>
        </member>
        <member name="M:CoAP.Option.Create(CoAP.OptionType,System.Byte[])">
            <summary>
            Creates an option.
            </summary>
            <param name="type">The type of the option</param>
            <param name="raw">The raw bytes value of the option</param>
            <returns>The new option</returns>
        </member>
        <member name="M:CoAP.Option.Create(CoAP.OptionType,System.String)">
            <summary>
            Creates an option.
            </summary>
            <param name="type">The type of the option</param>
            <param name="str">The string value of the option</param>
            <returns>The new option</returns>
        </member>
        <member name="M:CoAP.Option.Create(CoAP.OptionType,System.Int32)">
            <summary>
            Creates an option.
            </summary>
            <param name="type">The type of the option</param>
            <param name="val">The int value of the option</param>
            <returns>The new option</returns>
        </member>
        <member name="M:CoAP.Option.Create(CoAP.OptionType,System.Int64)">
            <summary>
            Creates an option.
            </summary>
            <param name="type">The type of the option</param>
            <param name="val">The long value of the option</param>
            <returns>The new option</returns>
        </member>
        <member name="M:CoAP.Option.Split(CoAP.OptionType,System.String,System.String)">
            <summary>
            Splits a string into a set of options, e.g. a uri path.
            </summary>
            <param name="type">The type of options</param>
            <param name="s">The string to be splited</param>
            <param name="delimiter">The seperator string</param>
            <returns><see cref="T:System.Collections.Generic.IEnumerable`1"/> of options</returns>
        </member>
        <member name="M:CoAP.Option.Join(System.Collections.Generic.IEnumerable{CoAP.Option},System.String)">
            <summary>
            Joins the string values of a set of options.
            </summary>
            <param name="options">The list of options to be joined</param>
            <param name="delimiter">The seperator string</param>
            <returns>The joined string</returns>
        </member>
        <member name="M:CoAP.Option.ToString(CoAP.OptionType)">
            <summary>
            Returns a string representation of the option type.
            </summary>
            <param name="type">The option type to describe</param>
            <returns>A string describing the option type</returns>
        </member>
        <member name="M:CoAP.Option.GetFormatByType(CoAP.OptionType)">
            <summary>
            Returns the option format based on the option type.
            </summary>
            <param name="type">the option type</param>
            <returns>the option format corresponding to the option type</returns>
        </member>
        <member name="M:CoAP.Option.IsCritical(CoAP.OptionType)">
            <summary>
            Checks whether an option is critical.
            </summary>
            <param name="type">the option type to check</param>
            <returns><code>true</code> if the option is critical</returns>
        </member>
        <member name="M:CoAP.Option.IsElective(CoAP.OptionType)">
            <summary>
            Checks whether an option is elective.
            </summary>
            <param name="type">the option type to check</param>
            <returns><code>true</code> if the option is elective</returns>
        </member>
        <member name="M:CoAP.Option.IsUnsafe(CoAP.OptionType)">
            <summary>
            Checks whether an option is unsafe.
            </summary>
            <param name="type">the option type to check</param>
            <returns><code>true</code> if the option is unsafe</returns>
        </member>
        <member name="M:CoAP.Option.IsSafe(CoAP.OptionType)">
            <summary>
            Checks whether an option is safe.
            </summary>
            <param name="type">the option type to check</param>
            <returns><code>true</code> if the option is safe</returns>
        </member>
        <member name="P:CoAP.Option.Type">
            <summary>
            Gets the type of the option.
            </summary>
        </member>
        <member name="P:CoAP.Option.Name">
            <summary>
            Gets the name of the option that corresponds to its type.
            </summary>
        </member>
        <member name="P:CoAP.Option.Length">
            <summary>
            Gets the value's length in bytes of the option.
            </summary>
        </member>
        <member name="P:CoAP.Option.RawValue">
            <summary>
            Gets or sets raw bytes value of the option in network byte order (big-endian).
            </summary>
        </member>
        <member name="P:CoAP.Option.StringValue">
            <summary>
            Gets or sets string value of the option.
            </summary>
        </member>
        <member name="P:CoAP.Option.IntValue">
            <summary>
            Gets or sets int value of the option.
            </summary>
        </member>
        <member name="P:CoAP.Option.LongValue">
            <summary>
            Gets or sets long value of the option.
            </summary>
        </member>
        <member name="P:CoAP.Option.Value">
            <summary>
            Gets the value of the option according to its type.
            </summary>
        </member>
        <member name="P:CoAP.Option.IsDefault">
            <summary>
            Gets a value indicating whether the option has a default value according to the draft.
            </summary>
        </member>
        <member name="F:CoAP.Net.Matcher._exchangesByID">
            <summary>
            for all
            </summary>
        </member>
        <member name="F:CoAP.Net.Matcher._exchangesByToken">
            <summary>
            for outgoing
            </summary>
        </member>
        <member name="F:CoAP.Net.Matcher._ongoingExchanges">
            <summary>
            for blockwise
            </summary>
        </member>
        <member name="M:CoAP.Net.Matcher.Start">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.Matcher.Stop">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.Matcher.Clear">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.Matcher.SendRequest(CoAP.Net.Exchange,CoAP.Request)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.Matcher.SendResponse(CoAP.Net.Exchange,CoAP.Response)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.Matcher.SendEmptyMessage(CoAP.Net.Exchange,CoAP.EmptyMessage)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.Matcher.ReceiveRequest(CoAP.Request)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.Matcher.ReceiveResponse(CoAP.Response)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.Matcher.ReceiveEmptyMessage(CoAP.EmptyMessage)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.Matcher.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:CoAP.Channel.UDPChannel">
            <summary>
            Channel via UDP protocol.
            </summary>
        </member>
        <member name="T:CoAP.Channel.IChannel">
            <summary>
            Represents a channel where bytes data can flow through.
            </summary>
        </member>
        <member name="M:CoAP.Channel.IChannel.Start">
            <summary>
            Starts this channel.
            </summary>
        </member>
        <member name="M:CoAP.Channel.IChannel.Stop">
            <summary>
            Stops this channel.
            </summary>
        </member>
        <member name="M:CoAP.Channel.IChannel.Send(System.Byte[],System.Net.EndPoint)">
            <summary>
            Sends data through this channel. This method should be non-blocking.
            </summary>
            <param name="data">the bytes to send</param>
            <param name="ep">the target endpoint</param>
        </member>
        <member name="P:CoAP.Channel.IChannel.LocalEndPoint">
            <summary>
            Gets the local endpoint of this channel.
            </summary>
        </member>
        <member name="E:CoAP.Channel.IChannel.DataReceived">
            <summary>
            Occurs when some bytes are received in this channel.
            </summary>
        </member>
        <member name="F:CoAP.Channel.UDPChannel.DefaultReceivePacketSize">
            <summary>
            Default size of buffer for receiving packet.
            </summary>
        </member>
        <member name="M:CoAP.Channel.UDPChannel.#ctor">
            <summary>
            Initializes a UDP channel with a random port.
            </summary>
        </member>
        <member name="M:CoAP.Channel.UDPChannel.#ctor(System.Int32)">
            <summary>
            Initializes a UDP channel with the given port, both on IPv4 and IPv6.
            </summary>
        </member>
        <member name="M:CoAP.Channel.UDPChannel.#ctor(System.Net.EndPoint)">
            <summary>
            Initializes a UDP channel with the specific endpoint.
            </summary>
        </member>
        <member name="M:CoAP.Channel.UDPChannel.Start">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Channel.UDPChannel.Stop">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Channel.UDPChannel.Send(System.Byte[],System.Net.EndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Channel.UDPChannel.Dispose">
            <inheritdoc/>
        </member>
        <member name="E:CoAP.Channel.UDPChannel.DataReceived">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Channel.UDPChannel.LocalEndPoint">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Channel.UDPChannel.ReceiveBufferSize">
            <summary>
            Gets or sets the <see cref="P:System.Net.Sockets.Socket.ReceiveBufferSize"/>.
            </summary>
        </member>
        <member name="P:CoAP.Channel.UDPChannel.SendBufferSize">
            <summary>
            Gets or sets the <see cref="P:System.Net.Sockets.Socket.SendBufferSize"/>.
            </summary>
        </member>
        <member name="P:CoAP.Channel.UDPChannel.ReceivePacketSize">
            <summary>
            Gets or sets the size of buffer for receiving packet.
            The default value is <see cref="F:CoAP.Channel.UDPChannel.DefaultReceivePacketSize"/>.
            </summary>
        </member>
        <member name="T:CoAP.Util.ByteArrayUtils">
            <summary>
            Utility methods for bytes array.
            </summary>
        </member>
        <member name="M:CoAP.Util.ByteArrayUtils.ToHexString(System.Byte[])">
            <summary>
            Returns a hex string representation of the given bytes array.
            </summary>
        </member>
        <member name="M:CoAP.Util.ByteArrayUtils.FromHexStream(System.String)">
            <summary>
            Parses a bytes array from its hex string representation.
            </summary>
        </member>
        <member name="M:CoAP.Util.ByteArrayUtils.Equals(System.Byte[],System.Byte[])">
            <summary>
            Checks if the two bytes arrays are equal.
            </summary>
        </member>
        <member name="M:CoAP.Util.ByteArrayUtils.ComputeHash(System.Byte[])">
            <summary>
            Computes the hash of the given bytes array.
            </summary>
        </member>
        <member name="T:CoAP.Log.TextWriterLogger">
            <summary>
            Logger that writes logs to a <see cref="T:System.IO.TextWriter"/>.
            </summary>
        </member>
        <member name="T:CoAP.Log.ILogger">
            <summary>
            Provides methods to log messages.
            </summary>
        </member>
        <member name="M:CoAP.Log.ILogger.Debug(System.Object)">
            <summary>
            Logs a debug message.
            </summary>
        </member>
        <member name="M:CoAP.Log.ILogger.Debug(System.Object,System.Exception)">
            <summary>
            Logs a debug message.
            </summary>
        </member>
        <member name="M:CoAP.Log.ILogger.Error(System.Object)">
            <summary>
            Logs an error message.
            </summary>
        </member>
        <member name="M:CoAP.Log.ILogger.Error(System.Object,System.Exception)">
            <summary>
            Logs an error message.
            </summary>
        </member>
        <member name="M:CoAP.Log.ILogger.Fatal(System.Object)">
            <summary>
            Logs a fatal message.
            </summary>
        </member>
        <member name="M:CoAP.Log.ILogger.Fatal(System.Object,System.Exception)">
            <summary>
            Logs a fatal message.
            </summary>
        </member>
        <member name="M:CoAP.Log.ILogger.Info(System.Object)">
            <summary>
            Logs an info message.
            </summary>
        </member>
        <member name="M:CoAP.Log.ILogger.Info(System.Object,System.Exception)">
            <summary>
            Logs an info message.
            </summary>
        </member>
        <member name="M:CoAP.Log.ILogger.Warn(System.Object)">
            <summary>
            Logs a warning message.
            </summary>
        </member>
        <member name="M:CoAP.Log.ILogger.Warn(System.Object,System.Exception)">
            <summary>
            Logs a warning message.
            </summary>
        </member>
        <member name="P:CoAP.Log.ILogger.IsDebugEnabled">
            <summary>
            Is debug enabled?
            </summary>
        </member>
        <member name="P:CoAP.Log.ILogger.IsErrorEnabled">
            <summary>
            Is error enabled?
            </summary>
        </member>
        <member name="P:CoAP.Log.ILogger.IsFatalEnabled">
            <summary>
            Is fatal enabled?
            </summary>
        </member>
        <member name="P:CoAP.Log.ILogger.IsInfoEnabled">
            <summary>
            Is info enabled?
            </summary>
        </member>
        <member name="P:CoAP.Log.ILogger.IsWarnEnabled">
            <summary>
            Is warning enabled?
            </summary>
        </member>
        <member name="M:CoAP.Log.TextWriterLogger.#ctor(System.IO.TextWriter)">
            <summary>
            Instantiates.
            </summary>
        </member>
        <member name="M:CoAP.Log.TextWriterLogger.Error(System.Object,System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Log.TextWriterLogger.Warning(System.Object,System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Log.TextWriterLogger.Info(System.Object,System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Log.TextWriterLogger.Debug(System.Object,System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Log.TextWriterLogger.Debug(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Log.TextWriterLogger.Debug(System.Object,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Log.TextWriterLogger.Error(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Log.TextWriterLogger.Error(System.Object,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Log.TextWriterLogger.Fatal(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Log.TextWriterLogger.Fatal(System.Object,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Log.TextWriterLogger.Info(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Log.TextWriterLogger.Info(System.Object,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Log.TextWriterLogger.Warn(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Log.TextWriterLogger.Warn(System.Object,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Log.TextWriterLogger.IsDebugEnabled">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Log.TextWriterLogger.IsInfoEnabled">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Log.TextWriterLogger.IsErrorEnabled">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Log.TextWriterLogger.IsFatalEnabled">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Log.TextWriterLogger.IsWarnEnabled">
            <inheritdoc/>
        </member>
        <member name="T:CoAP.Deduplication.IDeduplicator">
            <summary>
            Provides methods to detect duplicates.
            Notice that CONs and NONs can be duplicates.
            </summary>
        </member>
        <member name="M:CoAP.Deduplication.IDeduplicator.Start">
            <summary>
            Starts.
            </summary>
        </member>
        <member name="M:CoAP.Deduplication.IDeduplicator.Stop">
            <summary>
            Stops.
            </summary>
        </member>
        <member name="M:CoAP.Deduplication.IDeduplicator.Clear">
            <summary>
            Clears the state of this deduplicator.
            </summary>
        </member>
        <member name="M:CoAP.Deduplication.IDeduplicator.FindPrevious(CoAP.Net.Exchange.KeyID,CoAP.Net.Exchange)">
            <summary>
            Checks if the specified key is already associated with a previous
            exchange and otherwise associates the key with the exchange specified.
            </summary>
            <param name="key"></param>
            <param name="exchange"></param>
            <returns>the previous exchange associated with the specified key,
            or <code>null</code> if there was no mapping for the key</returns>
        </member>
        <member name="M:CoAP.Deduplication.CropRotation.Start">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Deduplication.CropRotation.Stop">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Deduplication.CropRotation.Clear">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Deduplication.CropRotation.FindPrevious(CoAP.Net.Exchange.KeyID,CoAP.Net.Exchange)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Deduplication.CropRotation.Find(CoAP.Net.Exchange.KeyID)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Deduplication.CropRotation.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:CoAP.Code">
            <summary>
            This class describes the CoAP Code Registry as defined in 
            draft-ietf-core-coap-08, section 11.1
            </summary>
        </member>
        <member name="F:CoAP.Code.GET">
            <summary>
            The GET method
            </summary>
        </member>
        <member name="F:CoAP.Code.POST">
            <summary>
            The POST method
            </summary>
        </member>
        <member name="F:CoAP.Code.PUT">
            <summary>
            The PUT method
            </summary>
        </member>
        <member name="F:CoAP.Code.DELETE">
            <summary>
            The DELETE method
            </summary>
        </member>
        <member name="F:CoAP.Code.Created">
            <summary>
            2.01 Created
            </summary>
        </member>
        <member name="F:CoAP.Code.Deleted">
            <summary>
            2.02 Deleted
            </summary>
        </member>
        <member name="F:CoAP.Code.Valid">
            <summary>
            2.03 Valid 
            </summary>
        </member>
        <member name="F:CoAP.Code.Changed">
            <summary>
            2.04 Changed
            </summary>
        </member>
        <member name="F:CoAP.Code.Content">
            <summary>
            2.05 Content
            </summary>
        </member>
        <member name="F:CoAP.Code.Continue">
            <summary>
            2.?? Continue
            </summary>
        </member>
        <member name="F:CoAP.Code.BadRequest">
            <summary>
            4.00 Bad Request
            </summary>
        </member>
        <member name="F:CoAP.Code.Unauthorized">
            <summary>
            4.01 Unauthorized
            </summary>
        </member>
        <member name="F:CoAP.Code.BadOption">
            <summary>
            4.02 Bad Option
            </summary>
        </member>
        <member name="F:CoAP.Code.Forbidden">
            <summary>
            4.03 Forbidden
            </summary>
        </member>
        <member name="F:CoAP.Code.NotFound">
            <summary>
            4.04 Not Found
            </summary>
        </member>
        <member name="F:CoAP.Code.MethodNotAllowed">
            <summary>
            4.05 Method Not Allowed
            </summary>
        </member>
        <member name="F:CoAP.Code.NotAcceptable">
            <summary>
            4.06 Not Acceptable
            </summary>
        </member>
        <member name="F:CoAP.Code.RequestEntityIncomplete">
            <summary>
            4.08 Request Entity Incomplete (draft-ietf-core-block)
            </summary>
        </member>
        <member name="F:CoAP.Code.PreconditionFailed">
            <summary>
            
            </summary>
        </member>
        <member name="F:CoAP.Code.RequestEntityTooLarge">
            <summary>
            4.13 Request Entity Too Large
            </summary>
        </member>
        <member name="F:CoAP.Code.UnsupportedMediaType">
            <summary>
            4.15 Unsupported Media Type
            </summary>
        </member>
        <member name="F:CoAP.Code.InternalServerError">
            <summary>
            5.00 Internal Server Error
            </summary>
        </member>
        <member name="F:CoAP.Code.NotImplemented">
            <summary>
            5.01 Not Implemented
            </summary>
        </member>
        <member name="F:CoAP.Code.BadGateway">
            <summary>
            5.02 Bad Gateway
            </summary>
        </member>
        <member name="F:CoAP.Code.ServiceUnavailable">
            <summary>
            5.03 Service Unavailable 
            </summary>
        </member>
        <member name="F:CoAP.Code.GatewayTimeout">
            <summary>
            5.04 Gateway Timeout
            </summary>
        </member>
        <member name="F:CoAP.Code.ProxyingNotSupported">
            <summary>
            5.05 Proxying Not Supported
            </summary>
        </member>
        <member name="M:CoAP.Code.IsRequest(System.Int32)">
            <summary>
            Checks whether a code indicates a request
            </summary>
            <param name="code">The code to be checked</param>
            <returns>True iff the code indicates a request</returns>
        </member>
        <member name="M:CoAP.Code.IsResponse(System.Int32)">
            <summary>
            Checks whether a code indicates a response
            </summary>
            <param name="code">The code to be checked</param>
            <returns>True iff the code indicates a response</returns>
        </member>
        <member name="M:CoAP.Code.IsSuccess(System.Int32)">
            <summary>
            Checks whether a code represents a success code.
            </summary>
        </member>
        <member name="M:CoAP.Code.IsValid(System.Int32)">
            <summary>
            Checks whether a code is valid
            </summary>
            <param name="code">The code to be checked</param>
            <returns>True iff the code is valid</returns>
        </member>
        <member name="M:CoAP.Code.ToString(System.Int32)">
            <summary>
            Returns a string representation of the code
            </summary>
            <param name="code">The code to be described</param>
            <returns>A string describing the code</returns>
        </member>
        <member name="T:CoAP.Method">
            <summary>
            Methods of request
            </summary>
        </member>
        <member name="F:CoAP.Method.GET">
            <summary>
            GET method
            </summary>
        </member>
        <member name="F:CoAP.Method.POST">
            <summary>
            POST method
            </summary>
        </member>
        <member name="F:CoAP.Method.PUT">
            <summary>
            PUT method
            </summary>
        </member>
        <member name="F:CoAP.Method.DELETE">
            <summary>
            DELETE method
            </summary>
        </member>
        <member name="T:CoAP.StatusCode">
            <summary>
            Response status codes.
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.Created">
            <summary>
            2.01 Created
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.Deleted">
            <summary>
            2.02 Deleted
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.Valid">
            <summary>
            2.03 Valid 
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.Changed">
            <summary>
            2.04 Changed
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.Content">
            <summary>
            2.05 Content
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.Continue">
            <summary>
            2.?? Continue
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.BadRequest">
            <summary>
            4.00 Bad Request
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.Unauthorized">
            <summary>
            4.01 Unauthorized
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.BadOption">
            <summary>
            4.02 Bad Option
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.Forbidden">
            <summary>
            4.03 Forbidden
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.NotFound">
            <summary>
            4.04 Not Found
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.MethodNotAllowed">
            <summary>
            4.05 Method Not Allowed
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.NotAcceptable">
            <summary>
            4.06 Not Acceptable
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.RequestEntityIncomplete">
            <summary>
            4.08 Request Entity Incomplete (draft-ietf-core-block)
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.PreconditionFailed">
            <summary>
            
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.RequestEntityTooLarge">
            <summary>
            4.13 Request Entity Too Large
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.UnsupportedMediaType">
            <summary>
            4.15 Unsupported Media Type
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.InternalServerError">
            <summary>
            5.00 Internal Server Error
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.NotImplemented">
            <summary>
            5.01 Not Implemented
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.BadGateway">
            <summary>
            5.02 Bad Gateway
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.ServiceUnavailable">
            <summary>
            5.03 Service Unavailable 
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.GatewayTimeout">
            <summary>
            5.04 Gateway Timeout
            </summary>
        </member>
        <member name="F:CoAP.StatusCode.ProxyingNotSupported">
            <summary>
            5.05 Proxying Not Supported
            </summary>
        </member>
        <member name="T:CoAP.Server.CoapServer">
            <summary>
            Represents an execution environment for CoAP <see cref="T:CoAP.Server.Resources.IResource"/>s.
            </summary>
        </member>
        <member name="T:CoAP.Server.IServer">
            <summary>
            Represents an execution environment for CoAP <see cref="T:CoAP.Server.Resources.IResource"/>s.
            
            A server hosts a tree of <see cref="T:CoAP.Server.Resources.IResource"/>s which are exposed to clients by
            means of one or more <see cref="T:CoAP.Net.IEndPoint"/>s which are bound to a network interface.
            Resources can be added and removed from the server dynamically during runtime.
            </summary>
        </member>
        <member name="M:CoAP.Server.IServer.AddEndPoint(CoAP.Net.IEndPoint)">
            <summary>
            Adds an endpoint for receive and sending CoAP messages on.
            </summary>
        </member>
        <member name="M:CoAP.Server.IServer.AddEndPoint(System.Net.IPEndPoint)">
            <summary>
            Adds an <see cref="T:System.Net.IPEndPoint"/> for receive and sending CoAP messages on.
            </summary>
        </member>
        <member name="M:CoAP.Server.IServer.AddEndPoint(System.Net.IPAddress,System.Int32)">
            <summary>
            Adds an <see cref="T:System.Net.IPAddress"/> and a port for receive and sending CoAP messages on.
            </summary>
        </member>
        <member name="M:CoAP.Server.IServer.FindEndPoint(System.Net.EndPoint)">
            <summary>
            Finds the endpoint bound to a particular <see cref="T:System.Net.EndPoint"/>.
            </summary>
            <returns>the endpoint or <code>null</code> if none of the server's
            endpoints is bound to the given <see cref="T:System.Net.EndPoint"/></returns>
        </member>
        <member name="M:CoAP.Server.IServer.FindEndPoint(System.Int32)">
            <summary>
            Finds the endpoint bound to a particular port.
            </summary>
            <returns>the endpoint or <code>null</code> if none of the
            server's endpoints is bound to the given port</returns>
        </member>
        <member name="M:CoAP.Server.IServer.Add(CoAP.Server.Resources.IResource)">
            <summary>
            Add one resource to the server.
            </summary>
        </member>
        <member name="M:CoAP.Server.IServer.Add(CoAP.Server.Resources.IResource[])">
            <summary>
            Adds one or more resources to the server.
            </summary>
        </member>
        <member name="M:CoAP.Server.IServer.Remove(CoAP.Server.Resources.IResource)">
            <summary>
            Removes a resource from the server.
            </summary>
            <returns><code>true</code> if the resource has been removed successfully</returns>
        </member>
        <member name="M:CoAP.Server.IServer.Start">
            <summary>
            Starts the server by starting all endpoints this server is assigned to.
            </summary>
        </member>
        <member name="M:CoAP.Server.IServer.Stop">
            <summary>
            Stops the server.
            </summary>
        </member>
        <member name="M:CoAP.Server.CoapServer.#ctor">
            <summary>
            Constructs a server with default configuration.
            </summary>
        </member>
        <member name="M:CoAP.Server.CoapServer.#ctor(System.Int32[])">
            <summary>
            Constructs a server that listens to the specified port(s).
            </summary>
            <param name="ports">the ports to bind to</param>
        </member>
        <member name="M:CoAP.Server.CoapServer.#ctor(CoAP.ICoapConfig,System.Int32[])">
            <summary>
            Constructs a server with the specified configuration that
            listens to the given ports.
            </summary>
            <param name="config">the configuration, or <code>null</code> for default</param>
            <param name="ports">the ports to bind to</param>
        </member>
        <member name="M:CoAP.Server.CoapServer.AddEndPoint(CoAP.Net.IEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Server.CoapServer.AddEndPoint(System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Server.CoapServer.AddEndPoint(System.Net.IPAddress,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Server.CoapServer.FindEndPoint(System.Net.EndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Server.CoapServer.FindEndPoint(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Server.CoapServer.Add(CoAP.Server.Resources.IResource)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Server.CoapServer.Add(CoAP.Server.Resources.IResource[])">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Server.CoapServer.Remove(CoAP.Server.Resources.IResource)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Server.CoapServer.Start">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Server.CoapServer.Stop">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Server.CoapServer.Dispose">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Server.CoapServer.EndPoints">
            <inheritdoc/>
        </member>
        <member name="T:CoAP.Server.Resources.Resource">
            <summary>
            Basic implementation of a resource.
            Extend this class to write your own resources.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.IResource.Add(CoAP.Server.Resources.IResource)">
            <summary>
            Adds the specified resource as child.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.IResource.Remove(CoAP.Server.Resources.IResource)">
            <summary>
            Removes the the specified child.
            </summary>
            <param name="child"></param>
            <returns>true if the child was found, otherwise false</returns>
        </member>
        <member name="M:CoAP.Server.Resources.IResource.GetChild(System.String)">
            <summary>
            Gets the child with the specified name.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:CoAP.Server.Resources.IResource.AddObserveRelation(CoAP.Observe.ObserveRelation)">
            <summary>
            Adds the specified CoAP observe relation.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.IResource.RemoveObserveRelation(CoAP.Observe.ObserveRelation)">
            <summary>
            Removes the specified CoAP observe relation.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.IResource.HandleRequest(CoAP.Net.Exchange)">
            <summary>
            Handles the request from the specified exchange.
            </summary>
            <param name="exchange">the exchange with the request</param>
        </member>
        <member name="P:CoAP.Server.Resources.IResource.Name">
            <summary>
            Gets or sets the name of the resource.
            Note that changing the name of a resource changes
            the path and URI of all children.
            Note that the parent of this resource must be notified
            that the name has changed so that it finds the
            resource under the correct new URI when another request arrives.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.IResource.Path">
            <summary>
            Gets or sets the path to the resource which is equal to
            the URI of its parent plus a slash.
            Note that changing the path of a resource also changes
            the path of all its children.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.IResource.Uri">
            <summary>
            Gets the uri of the resource.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.IResource.Visible">
            <summary>
            Checks if the resource is visible to remote CoAP clients.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.IResource.Cachable">
            <summary>
            Checks if is the URI of the resource can be cached.
            If another request with the same destination URI arrives,
            it can be forwarded to this resource right away instead of
            traveling through the resource tree looking for it.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.IResource.Observable">
            <summary>
            Checks if this resource is observable by remote CoAP clients.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.IResource.Attributes">
            <summary>
            Gets the attributes of this resource.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.IResource.Executor">
            <summary>
            Gets the executor of this resource.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.IResource.EndPoints">
            <summary>
            Gets the endpoints this resource is bound to.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.IResource.Parent">
            <summary>
            Gets or sets the parent of this resource.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.IResource.Children">
            <summary>
            Gets all child resources.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.Resource.#ctor(System.String)">
            <summary>
            Constructs a new resource with the specified name.
            </summary>
            <param name="name">the name</param>
        </member>
        <member name="M:CoAP.Server.Resources.Resource.#ctor(System.String,System.Boolean)">
            <summary>
            Constructs a new resource with the specified name
            and makes it visible to clients if the flag is true.
            </summary>
            <param name="name">the name</param>
            <param name="visible">if the resource is visible or not</param>
        </member>
        <member name="M:CoAP.Server.Resources.Resource.Add(CoAP.Server.Resources.IResource)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Server.Resources.Resource.Remove(CoAP.Server.Resources.IResource)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Server.Resources.Resource.GetChild(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Server.Resources.Resource.AddObserveRelation(CoAP.Observe.ObserveRelation)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Server.Resources.Resource.RemoveObserveRelation(CoAP.Observe.ObserveRelation)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Server.Resources.Resource.ClearObserveRelations">
            <summary>
            Cancel all observe relations to CoAP clients.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.Resource.ClearAndNotifyObserveRelations(CoAP.StatusCode)">
            <summary>
            Remove all observe relations to CoAP clients and notify them that the
            observe relation has been canceled.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.Resource.HandleRequest(CoAP.Net.Exchange)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Server.Resources.Resource.DoGet(CoAP.Server.Resources.CoapExchange)">
            <summary>
            Handles the GET request in the given CoAPExchange.
            By default it responds with a 4.05 (Method Not Allowed).
            Override this method to respond differently.
            Possible response codes for GET requests are 2.05 (Content) and 2.03 (Valid).
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.Resource.DoPost(CoAP.Server.Resources.CoapExchange)">
            <summary>
            Handles the POST request in the given CoAPExchange.
            By default it responds with a 4.05 (Method Not Allowed).
            Override this method to respond differently.
            Possible response codes for POST requests are 2.01 (Created), 2.04 (Changed), and 2.02 (Deleted).
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.Resource.DoPut(CoAP.Server.Resources.CoapExchange)">
            <summary>
            Handles the PUT request in the given CoAPExchange.
            By default it responds with a 4.05 (Method Not Allowed).
            Override this method to respond differently.
            Possible response codes for PUT requests are 2.01 (Created) and 2.04 (Changed).
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.Resource.DoDelete(CoAP.Server.Resources.CoapExchange)">
            <summary>
            Handles the DELETE request in the given CoAPExchange.
            By default it responds with a 4.05 (Method Not Allowed).
            Override this method to respond differently.
            The response code to a DELETE request should be a 2.02 (Deleted).
            </summary>
        </member>
        <!-- 对于成员“M:CoAP.Server.Resources.Resource.Changed”忽略有格式错误的 XML 注释 -->
        <member name="M:CoAP.Server.Resources.Resource.Changed(CoAP.Func{CoAP.Observe.ObserveRelation,System.Boolean})">
            <summary>
            Notifies a filtered set of CoAP clients that have established an observe
            relation with this resource that the state has changed by reprocessing
            their original request that has established the relation. The notification
            is done by the executor of this resource or on the executor of its parent or
            transitively ancestor. If no ancestor defines its own executor, the
            thread that has called this method performs the notification.
            </summary>
            <param name="filter">the filter to select set of relations,
            or <code>null</code> if all clients should be notified</param>
        </member>
        <member name="M:CoAP.Server.Resources.Resource.NotifyObserverRelations(CoAP.Func{CoAP.Observe.ObserveRelation,System.Boolean})">
            <summary>
            Notifies all CoAP clients that have established an observe relation with
            this resource that the state has changed by reprocessing their original
            request that has established the relation.
            </summary>
            <param name="filter">the filter to select set of relations,
            or <code>null</code> if all clients should be notified</param>
        </member>
        <member name="P:CoAP.Server.Resources.Resource.Name">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Server.Resources.Resource.Path">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Server.Resources.Resource.Uri">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Server.Resources.Resource.Visible">
            <summary>
            Gets or sets a value indicating if the resource is visible to remote CoAP clients.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.Resource.Cachable">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Server.Resources.Resource.Observable">
            <summary>
            Gets or sets a value indicating if this resource is observable by remote CoAP clients.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.Resource.ObserveType">
            <summary>
            Gets or sets the type of the notifications that will be sent.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.Resource.Attributes">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Server.Resources.Resource.Executor">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Server.Resources.Resource.EndPoints">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Server.Resources.Resource.Parent">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Server.Resources.Resource.Children">
            <inheritdoc/>
        </member>
        <member name="T:CoAP.EndPoint.Resources.Resource">
            <summary>
            This class describes the functionality of a CoAP resource.
            </summary>
        </member>
        <member name="M:CoAP.EndPoint.Resources.Resource.#ctor(System.String)">
            <summary>
            Initialize a resource.
            </summary>
            <param name="resourceIdentifier">The identifier of this resource</param>
        </member>
        <member name="M:CoAP.EndPoint.Resources.Resource.#ctor(System.String,System.Boolean)">
            <summary>
            Initialize a resource.
            </summary>
            <param name="resourceIdentifier">The identifier of this resource</param>
            <param name="hidden">True if this resource is hidden</param>
        </member>
        <member name="M:CoAP.EndPoint.Resources.Resource.Remove">
            <summary>
            Removes this resource from its parent.
            </summary>
        </member>
        <member name="M:CoAP.EndPoint.Resources.Resource.GetSubResources">
            <summary>
            Gets sub-resources of this resource.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CoAP.EndPoint.Resources.Resource.AddSubResource(CoAP.EndPoint.Resources.Resource)">
            <summary>
            Adds a resource as a sub-resource of this resource.
            </summary>
            <param name="resource">The sub-resource to be added</param>
        </member>
        <member name="M:CoAP.EndPoint.Resources.Resource.RemoveSubResource(System.String)">
            <summary>
            Removes a sub-resource from this resource by its identifier.
            </summary>
            <param name="resourcePath">the path of the sub-resource to remove</param>
        </member>
        <member name="M:CoAP.EndPoint.Resources.Resource.RemoveSubResource(CoAP.EndPoint.Resources.Resource)">
            <summary>
            Removes a sub-resource from this resource.
            </summary>
            <param name="resource">the sub-resource to remove</param>
        </member>
        <member name="M:CoAP.EndPoint.Resources.Resource.CreateInstance(System.String)">
            <summary>
            Creates a resouce instance with proper subtype.
            </summary>
            <returns></returns>
        </member>
        <member name="P:CoAP.EndPoint.Resources.Resource.Path">
            <summary>
            Gets the URI of this resource.
            </summary>
        </member>
        <member name="P:CoAP.EndPoint.Resources.Resource.ResourceType">
            <summary>
            Gets or sets the type attribute of this resource.
            </summary>
        </member>
        <member name="P:CoAP.EndPoint.Resources.Resource.Title">
            <summary>
            Gets or sets the title attribute of this resource.
            </summary>
        </member>
        <member name="P:CoAP.EndPoint.Resources.Resource.InterfaceDescription">
            <summary>
            Gets or sets the interface description attribute of this resource.
            </summary>
        </member>
        <member name="P:CoAP.EndPoint.Resources.Resource.ContentTypeCode">
            <summary>
            Gets or sets the content type code attribute of this resource.
            </summary>
        </member>
        <member name="P:CoAP.EndPoint.Resources.Resource.MaximumSizeEstimate">
            <summary>
            Gets or sets the maximum size estimate attribute of this resource.
            </summary>
        </member>
        <member name="P:CoAP.EndPoint.Resources.Resource.Observable">
            <summary>
            Gets or sets the observable attribute of this resource.
            </summary>
        </member>
        <member name="P:CoAP.EndPoint.Resources.Resource.TotalSubResourceCount">
            <summary>
            Gets the total count of sub-resources, including children and children's children...
            </summary>
        </member>
        <member name="P:CoAP.EndPoint.Resources.Resource.SubResourceCount">
            <summary>
            Gets the count of sub-resources of this resource.
            </summary>
        </member>
        <member name="M:CoAP.EndPoint.Resources.RemoteResource.CreateInstance(System.String)">
            <summary>
            Creates a resouce instance with proper subtype.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CoAP.Deduplication.SweepDeduplicator.Start">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Deduplication.SweepDeduplicator.Stop">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Deduplication.SweepDeduplicator.Clear">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Deduplication.SweepDeduplicator.FindPrevious(CoAP.Net.Exchange.KeyID,CoAP.Net.Exchange)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Deduplication.SweepDeduplicator.Find(CoAP.Net.Exchange.KeyID)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Deduplication.SweepDeduplicator.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:CoAP.Codec.DatagramWriter">
            <summary>
            This class describes the functionality to write raw network-ordered datagrams on bit-level.
            </summary>
        </member>
        <member name="M:CoAP.Codec.DatagramWriter.#ctor">
            <summary>
            Initializes a new DatagramWriter object
            </summary>
        </member>
        <member name="M:CoAP.Codec.DatagramWriter.Write(System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bits to the stream
            </summary>
            <param name="data">An integer containing the bits to write</param>
            <param name="numBits">The number of bits to write</param>
        </member>
        <member name="M:CoAP.Codec.DatagramWriter.WriteBytes(System.Byte[])">
            <summary>
            Writes a sequence of bytes to the stream
            </summary>
            <param name="bytes">The sequence of bytes to write</param>
        </member>
        <member name="M:CoAP.Codec.DatagramWriter.WriteByte(System.Byte)">
            <summary>
            Writes one byte to the stream.
            </summary>
        </member>
        <member name="M:CoAP.Codec.DatagramWriter.ToByteArray">
            <summary>
            Returns a byte array containing the sequence of bits written
            </summary>
            <returns>The byte array containing the written bits</returns>
        </member>
        <member name="T:CoAP.Codec.DatagramReader">
            <summary>
            This class describes the functionality to read raw network-ordered datagrams on bit-level.
            </summary>
        </member>
        <member name="M:CoAP.Codec.DatagramReader.#ctor(System.Byte[])">
            <summary>
            Initializes a new DatagramReader object
            </summary>
            <param name="buffer">The byte array to read from</param>
        </member>
        <member name="M:CoAP.Codec.DatagramReader.Read(System.Int32)">
            <summary>
            Reads a sequence of bits from the stream
            </summary>
            <param name="numBits">The number of bits to read</param>
            <returns>An integer containing the bits read</returns>
        </member>
        <member name="M:CoAP.Codec.DatagramReader.ReadBytes(System.Int32)">
            <summary>
            Reads a sequence of bytes from the stream
            </summary>
            <param name="count">The number of bytes to read</param>
            <returns>The sequence of bytes read from the stream</returns>
        </member>
        <member name="M:CoAP.Codec.DatagramReader.ReadNextByte">
            <summary>
            Reads the next byte from the stream.
            </summary>
        </member>
        <member name="M:CoAP.Codec.DatagramReader.ReadBytesLeft">
            <summary>
            Reads the complete sequence of bytes left in the stream
            </summary>
            <returns>The sequence of bytes left in the stream</returns>
        </member>
        <member name="P:CoAP.Codec.DatagramReader.BytesAvailable">
            <summary>
            Checks if there are remaining bytes to read.
            </summary>
        </member>
        <member name="T:CoAP.Net.IEndPoint">
            <summary>
            Represents a communication endpoint multiplexing CoAP message exchanges
            between (potentially multiple) clients and servers.
            </summary>
        </member>
        <member name="M:CoAP.Net.IEndPoint.Start">
            <summary>
            Starts this endpoint and all its components.
            </summary>
        </member>
        <member name="M:CoAP.Net.IEndPoint.Stop">
            <summary>
            Stops this endpoint and all its components
            </summary>
        </member>
        <member name="M:CoAP.Net.IEndPoint.SendRequest(CoAP.Request)">
            <summary>
            Sends the specified request.
            </summary>
            <param name="request"></param>
        </member>
        <member name="M:CoAP.Net.IEndPoint.SendResponse(CoAP.Net.Exchange,CoAP.Response)">
            <summary>
            Sends the specified response.
            </summary>
        </member>
        <member name="M:CoAP.Net.IEndPoint.SendEmptyMessage(CoAP.Net.Exchange,CoAP.EmptyMessage)">
            <summary>
            Sends the specified empty message.
            </summary>
        </member>
        <member name="P:CoAP.Net.IEndPoint.Config">
            <summary>
            Gets this endpoint's configuration.
            </summary>
        </member>
        <member name="P:CoAP.Net.IEndPoint.LocalEndPoint">
            <summary>
            Gets the local <see cref="T:System.Net.EndPoint"/> this endpoint is associated with.
            </summary>
        </member>
        <member name="P:CoAP.Net.IEndPoint.Running">
            <summary>
            Checks if the endpoint has started.
            </summary>
        </member>
        <member name="P:CoAP.Net.IEndPoint.MessageDeliverer">
            <summary>
            Gets or sets the message deliverer.
            </summary>
        </member>
        <member name="P:CoAP.Net.IEndPoint.Outbox">
            <summary>
            Gets the outbox.
            </summary>
        </member>
        <member name="E:CoAP.Net.IEndPoint.SendingRequest">
            <summary>
            Occurs when a request is about to be sent.
            </summary>
        </member>
        <member name="E:CoAP.Net.IEndPoint.SendingResponse">
            <summary>
            Occurs when a response is about to be sent.
            </summary>
        </member>
        <member name="E:CoAP.Net.IEndPoint.SendingEmptyMessage">
            <summary>
            Occurs when a an empty message is about to be sent.
            </summary>
        </member>
        <member name="E:CoAP.Net.IEndPoint.ReceivingRequest">
            <summary>
            Occurs when a request request has been received.
            </summary>
        </member>
        <member name="E:CoAP.Net.IEndPoint.ReceivingResponse">
            <summary>
            Occurs when a response has been received.
            </summary>
        </member>
        <member name="E:CoAP.Net.IEndPoint.ReceivingEmptyMessage">
            <summary>
            Occurs when an empty message has been received.
            </summary>
        </member>
        <member name="T:CoAP.Log.ILogManager">
            <summary>
            Provides methods to acquire <see cref="T:CoAP.Log.ILogger"/>.
            </summary>
        </member>
        <member name="M:CoAP.Log.ILogManager.GetLogger(System.Type)">
            <summary>
            Gets a logger of the given type.
            </summary>
        </member>
        <member name="M:CoAP.Log.ILogManager.GetLogger(System.String)">
            <summary>
            Gets a named logger.
            </summary>
        </member>
        <member name="T:CoAP.LinkFormat">
            <summary>
            This class provides link format definitions as specified in
            draft-ietf-core-link-format-06
            </summary>
        </member>
        <member name="F:CoAP.LinkFormat.ResourceType">
            <summary>
            Name of the attribute Resource Type
            </summary>
        </member>
        <member name="F:CoAP.LinkFormat.InterfaceDescription">
            <summary>
            Name of the attribute Interface Description
            </summary>
        </member>
        <member name="F:CoAP.LinkFormat.ContentType">
            <summary>
            Name of the attribute Content Type
            </summary>
        </member>
        <member name="F:CoAP.LinkFormat.MaxSizeEstimate">
            <summary>
            Name of the attribute Max Size Estimate
            </summary>
        </member>
        <member name="F:CoAP.LinkFormat.Title">
            <summary>
            Name of the attribute Title
            </summary>
        </member>
        <member name="F:CoAP.LinkFormat.Observable">
            <summary>
            Name of the attribute Observable
            </summary>
        </member>
        <member name="F:CoAP.LinkFormat.Link">
            <summary>
            Name of the attribute link
            </summary>
        </member>
        <member name="F:CoAP.LinkFormat.Delimiter">
            <summary>
            The string as the delimiter between resources
            </summary>
        </member>
        <member name="F:CoAP.LinkFormat.Separator">
            <summary>
            The string to separate attributes
            </summary>
        </member>
        <member name="T:CoAP.Codec.IMessageEncoder">
            <summary>
            Provides methods to serialize outgoing messages to byte arrays.
            </summary>
        </member>
        <member name="M:CoAP.Codec.IMessageEncoder.Encode(CoAP.Request)">
            <summary>
            Encodes a request into a bytes array.
            </summary>
            <param name="request">the request to encode</param>
            <returns>the encoded bytes</returns>
        </member>
        <member name="M:CoAP.Codec.IMessageEncoder.Encode(CoAP.Response)">
            <summary>
            Encodes a response into a bytes array.
            </summary>
            <param name="response">the response to encode</param>
            <returns>the encoded bytes</returns>
        </member>
        <member name="M:CoAP.Codec.IMessageEncoder.Encode(CoAP.EmptyMessage)">
            <summary>
            Encodes an empty message into a bytes array.
            </summary>
            <param name="message">the empty message to encode</param>
            <returns>the encoded bytes</returns>
        </member>
        <member name="M:CoAP.Codec.IMessageEncoder.Encode(CoAP.Message)">
            <summary>
            Encodes a CoAP message into a bytes array.
            </summary>
            <param name="message">the message to encode</param>
            <returns>
            the encoded bytes, or null if the message can not be encoded,
            i.e. the message is not a <see cref="T:CoAP.Request"/>, a <see cref="T:CoAP.Response"/> or an <see cref="T:CoAP.EmptyMessage"/>.
            </returns>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentDictionary`2">
            <summary>
            Represents a thread-safe collection of keys and values.
            </summary>
            <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
            <remarks>
            All public and protected members of <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> are thread-safe and may be used
            concurrently from multiple threads.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.IsValueWriteAtomic">
            <summary>
            Determines whether type TValue can be written atomically
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            class that is empty, has the default concurrency level, has the default initial capacity, and
            uses the default comparer for the key type.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            class that is empty, has the specified concurrency level and capacity, and uses the default
            comparer for the key type.
            </summary>
            <param name="concurrencyLevel">The estimated number of threads that will update the
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> concurrently.</param>
            <param name="capacity">The initial number of elements that the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            can contain.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="concurrencyLevel"/> is
            less than 1.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"> <paramref name="capacity"/> is less than
            0.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            class that contains elements copied from the specified <see cref="T:System.Collections.IEnumerable{KeyValuePair{TKey,TValue}}"/>, has the default concurrency
            level, has the default initial capacity, and uses the default comparer for the key type.
            </summary>
            <param name="collection">The <see cref="T:System.Collections.IEnumerable{KeyValuePair{TKey,TValue}}"/> whose elements are copied to
            the new
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException"><paramref name="collection"/> contains one or more
            duplicate keys.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            class that is empty, has the specified concurrency level and capacity, and uses the specified
            <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}"/>.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}"/>
            implementation to use when comparing keys.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="comparer"/> is a null reference
            (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            class that contains elements copied from the specified <see cref="T:System.Collections.IEnumerable"/>, has the default concurrency level, has the default
            initial capacity, and uses the specified
            <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}"/>.
            </summary>
            <param name="collection">The <see cref="T:System.Collections.IEnumerable{KeyValuePair{TKey,TValue}}"/> whose elements are copied to
            the new
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}"/>
            implementation to use when comparing keys.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/> is a null reference
            (Nothing in Visual Basic). -or-
            <paramref name="comparer"/> is a null reference (Nothing in Visual Basic).
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> 
            class that contains elements copied from the specified <see cref="T:System.Collections.IEnumerable"/>, 
            has the specified concurrency level, has the specified initial capacity, and uses the specified 
            <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}"/>.
            </summary>
            <param name="concurrencyLevel">The estimated number of threads that will update the 
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> concurrently.</param>
            <param name="collection">The <see cref="T:System.Collections.IEnumerable{KeyValuePair{TKey,TValue}}"/> whose elements are copied to the new 
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}"/> implementation to use 
            when comparing keys.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="collection"/> is a null reference (Nothing in Visual Basic).
            -or-
            <paramref name="comparer"/> is a null reference (Nothing in Visual Basic).
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="concurrencyLevel"/> is less than 1.
            </exception>
            <exception cref="T:System.ArgumentException"><paramref name="collection"/> contains one or more duplicate keys.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            class that is empty, has the specified concurrency level, has the specified initial capacity, and
            uses the specified <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}"/>.
            </summary>
            <param name="concurrencyLevel">The estimated number of threads that will update the
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> concurrently.</param>
            <param name="capacity">The initial number of elements that the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            can contain.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer{TKey}"/>
            implementation to use when comparing keys.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="concurrencyLevel"/> is less than 1. -or-
            <paramref name="capacity"/> is less than 0.
            </exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="comparer"/> is a null reference
            (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAdd(`0,`1)">
            <summary>
            Attempts to add the specified key and value to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value of the element to add. The value can be a null reference (Nothing
            in Visual Basic) for reference types.</param>
            <returns>true if the key/value pair was added to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            successfully; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            contains too many elements.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.ContainsKey(`0)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> contains the specified
            key.
            </summary>
            <param name="key">The key to locate in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</param>
            <returns>true if the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> contains an element with
            the specified key; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemove(`0,`1@)">
            <summary>
            Attempts to remove and return the the value with the specified key from the
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.
            </summary>
            <param name="key">The key of the element to remove and return.</param>
            <param name="value">When this method returns, <paramref name="value"/> contains the object removed from the
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> or the default value of <typeparamref name="TValue"/>
            if the operation failed.</param>
            <returns>true if an object was removed successfully; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryRemoveInternal(`0,`1@,System.Boolean,`1)">
            <summary>
            Removes the specified key from the dictionary if it exists and returns its associated value.
            If matchValue flag is set, the key will be removed only if is associated with a particular
            value.
            </summary>
            <param name="key">The key to search for and remove if it exists.</param>
            <param name="value">The variable into which the removed value, if found, is stored.</param>
            <param name="matchValue">Whether removal of the key is conditional on its value.</param>
            <param name="oldValue">The conditional value to compare against if <paramref name="matchValue"/> is true</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value associated with the specified key from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.
            </summary>
            <param name="key">The key of the value to get.</param>
            <param name="value">When this method returns, <paramref name="value"/> contains the object from
            the
            <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> with the specified key or the default value of
            <typeparamref name="TValue"/>, if the operation failed.</param>
            <returns>true if the key was found in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>;
            otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryUpdate(`0,`1,`1)">
            <summary>
            Compares the existing value for the specified key with a specified value, and if they're equal,
            updates the key with a third value.
            </summary>
            <param name="key">The key whose value is compared with <paramref name="comparisonValue"/> and
            possibly replaced.</param>
            <param name="newValue">The value that replaces the value of the element with <paramref
            name="key"/> if the comparison results in equality.</param>
            <param name="comparisonValue">The value that is compared to the value of the element with
            <paramref name="key"/>.</param>
            <returns>true if the value with <paramref name="key"/> was equal to <paramref
            name="comparisonValue"/> and replaced with <paramref name="newValue"/>; otherwise,
            false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null
            reference.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryUpdateInternal(`0,System.Int32,`1,`1)">
            <summary>
            Compares the existing value for the specified key with a specified value, and if they're equal,
            updates the key with a third value.
            </summary>
            <param name="key">The key whose value is compared with <paramref name="comparisonValue"/> and
            possibly replaced.</param>
            <param name="hashcode">The hashcode computed for <paramref name="key"/>.</param>
            <param name="newValue">The value that replaces the value of the element with <paramref
            name="key"/> if the comparison results in equality.</param>
            <param name="comparisonValue">The value that is compared to the value of the element with
            <paramref name="key"/>.</param>
            <returns>true if the value with <paramref name="key"/> was equal to <paramref
            name="comparisonValue"/> and replaced with <paramref name="newValue"/>; otherwise,
            false.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null
            reference.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.Clear">
            <summary>
            Removes all keys and values from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection"/> to an array of
            type <see cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}"/>, starting at the
            specified array index.
            </summary>
            <param name="array">The one-dimensional array of type <see
            cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}"/>
            that is the destination of the <see
            cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}"/> elements copied from the <see
            cref="T:System.Collections.ICollection"/>. The array must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying
            begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            0.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="index"/> is equal to or greater than
            the length of the <paramref name="array"/>. -or- The number of elements in the source <see
            cref="T:System.Collections.ICollection"/>
            is greater than the available space from <paramref name="index"/> to the end of the destination
            <paramref name="array"/>.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.ToArray">
            <summary>
            Copies the key and value pairs stored in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> to a
            new array.
            </summary>
            <returns>A new array containing a snapshot of key and value pairs copied from the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.CopyToPairs(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copy dictionary contents to an array - shared implementation between ToArray and CopyTo.
            
            Important: the caller must hold all locks in _locks before calling CopyToPairs.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.CopyToEntries(System.Collections.DictionaryEntry[],System.Int32)">
            <summary>
            Copy dictionary contents to an array - shared implementation between ToArray and CopyTo.
            
            Important: the caller must hold all locks in _locks before calling CopyToEntries.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.CopyToObjects(System.Object[],System.Int32)">
            <summary>
            Copy dictionary contents to an array - shared implementation between ToArray and CopyTo.
            
            Important: the caller must hold all locks in _locks before calling CopyToObjects.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetEnumerator">
            <summary>Returns an enumerator that iterates through the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</summary>
            <returns>An enumerator for the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</returns>
            <remarks>
            The enumerator returned from the dictionary is safe to use concurrently with
            reads and writes to the dictionary, however it does not represent a moment-in-time snapshot
            of the dictionary.  The contents exposed through the enumerator may contain modifications
            made to the dictionary after <see cref="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetEnumerator"/> was called.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.TryAddInternal(`0,System.Int32,`1,System.Boolean,System.Boolean,`1@)">
            <summary>
            Shared internal implementation for inserts and updates.
            If key exists, we always return false; and if updateIfExists == true we force update with value;
            If key doesn't exist, we always add value and return true;
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,System.Func{`0,`1})">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> 
            if the key does not already exist.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="valueFactory">The function used to generate a value for the key</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="valueFactory"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <returns>The value for the key.  This will be either the existing value for the key if the
            key is already in the dictionary, or the new value for the key as returned by valueFactory
            if the key was not in the dictionary.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(`0,`1)">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> 
            if the key does not already exist.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">the value to be added, if the key does not already exist</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <returns>The value for the key.  This will be either the existing value for the key if the 
            key is already in the dictionary, or the new value if the key was not in the dictionary.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,System.Func{`0,`1},System.Func{`0,`1,`1})">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> if the key does not already 
            exist, or updates a key/value pair in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> if the key 
            already exists.
            </summary>
            <param name="key">The key to be added or whose value should be updated</param>
            <param name="addValueFactory">The function used to generate a value for an absent key</param>
            <param name="updateValueFactory">The function used to generate a new value for an existing key
            based on the key's existing value</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="addValueFactory"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="updateValueFactory"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <returns>The new value for the key.  This will be either be the result of addValueFactory (if the key was 
            absent) or the result of updateValueFactory (if the key was present).</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AddOrUpdate(`0,`1,System.Func{`0,`1,`1})">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> if the key does not already 
            exist, or updates a key/value pair in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> if the key 
            already exists.
            </summary>
            <param name="key">The key to be added or whose value should be updated</param>
            <param name="addValue">The value to be added for an absent key</param>
            <param name="updateValueFactory">The function used to generate a new value for an existing key based on 
            the key's existing value</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="updateValueFactory"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <returns>The new value for the key.  This will be either be the result of addValueFactory (if the key was 
            absent) or the result of updateValueFactory (if the key was present).</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#Add(`0,`1)">
            <summary>
            Adds the specified key and value to the <see cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/>.
            </summary>
            <param name="key">The object to use as the key of the element to add.</param>
            <param name="value">The object to use as the value of the element to add.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <exception cref="T:System.ArgumentException">
            An element with the same key already exists in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#Remove(`0)">
            <summary>
            Removes the element with the specified key from the <see
            cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/>.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>true if the element is successfully remove; otherwise false. This method also returns
            false if
            <paramref name="key"/> was not found in the original <see
            cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Adds the specified value to the <see cref="T:System.Collections.Generic.ICollection{TValue}"/>
            with the specified key.
            </summary>
            <param name="keyValuePair">The <see cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}"/>
            structure representing the key and value to add to the <see
            cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/>.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="keyValuePair"/> of <paramref
            name="keyValuePair"/> is null.</exception>
            <exception cref="T:System.OverflowException">The <see
            cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/>
            contains too many elements.</exception>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the
            <see cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/></exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection{TKey,TValue}"/>
            contains a specific key and value.
            </summary>
            <param name="keyValuePair">The <see cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}"/>
            structure to locate in the <see
            cref="T:System.Collections.Generic.ICollection{TValue}"/>.</param>
            <returns>true if the <paramref name="keyValuePair"/> is found in the <see
            cref="T:System.Collections.Generic.ICollection{TKey,TValue}"/>; otherwise, false.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Removes a key and value from the dictionary.
            </summary>
            <param name="keyValuePair">The <see
            cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}"/>
            structure representing the key and value to remove from the <see
            cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/>.</param>
            <returns>true if the key and value represented by <paramref name="keyValuePair"/> is successfully
            found and removed; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">The Key property of <paramref
            name="keyValuePair"/> is a null reference (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</summary>
            <returns>An enumerator for the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</returns>
            <remarks>
            The enumerator returned from the dictionary is safe to use concurrently with
            reads and writes to the dictionary, however it does not represent a moment-in-time snapshot
            of the dictionary.  The contents exposed through the enumerator may contain modifications
            made to the dictionary after <see cref="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetEnumerator"/> was called.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>
            Adds the specified key and value to the dictionary.
            </summary>
            <param name="key">The object to use as the key.</param>
            <param name="value">The object to use as the value.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="key"/> is of a type that is not assignable to the key type <typeparamref
            name="TKey"/> of the <see cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/>. -or-
            <paramref name="value"/> is of a type that is not assignable to <typeparamref name="TValue"/>,
            the type of values in the <see cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/>.
            -or- A value with the same key already exists in the <see
            cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/>.
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
            <summary>
            Gets whether the <see cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/> contains an
            element with the specified key.
            </summary>
            <param name="key">The key to locate in the <see
            cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/>.</param>
            <returns>true if the <see cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/> contains
            an element with the specified key; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException"> <paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <summary>Provides an <see cref="T:System.Collections.Generics.IDictionaryEnumerator"/> for the
            <see cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/>.</summary>
            <returns>An <see cref="T:System.Collections.Generics.IDictionaryEnumerator"/> for the <see
            cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/>.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
            <summary>
            Removes the element with the specified key from the <see
            cref="T:System.Collections.IDictionary"/>.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"/> to an array, starting
            at the specified array index.
            </summary>
            <param name="array">The one-dimensional array that is the destination of the elements copied from
            the <see cref="T:System.Collections.ICollection"/>. The array must have zero-based
            indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying
            begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            0.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="index"/> is equal to or greater than
            the length of the <paramref name="array"/>. -or- The number of elements in the source <see
            cref="T:System.Collections.ICollection"/>
            is greater than the available space from <paramref name="index"/> to the end of the destination
            <paramref name="array"/>.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GrowTable(System.Collections.Concurrent.ConcurrentDictionary{`0,`1}.Tables)">
            <summary>
            Replaces the bucket table with a larger one. To prevent multiple threads from resizing the
            table as a result of races, the Tables instance that holds the table of buckets deemed too
            small is passed in as an argument to GrowTable(). GrowTable() obtains a lock, and then checks
            the Tables instance has been replaced in the meantime or not.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetBucket(System.Int32,System.Int32)">
            <summary>
            Computes the bucket for a particular key. 
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetBucketAndLockNo(System.Int32,System.Int32@,System.Int32@,System.Int32,System.Int32)">
            <summary>
            Computes the bucket and lock number for a particular key. 
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AcquireAllLocks(System.Int32@)">
            <summary>
            Acquires all locks for this hash table, and increments locksAcquired by the number
            of locks that were successfully acquired. The locks are acquired in an increasing
            order.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.AcquireLocks(System.Int32,System.Int32,System.Int32@)">
            <summary>
            Acquires a contiguous range of locks for this hash table, and increments locksAcquired
            by the number of locks that were successfully acquired. The locks are acquired in an
            increasing order.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.ReleaseLocks(System.Int32,System.Int32)">
            <summary>
            Releases a contiguous range of locks.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetKeys">
            <summary>
            Gets a collection containing the keys in the dictionary.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.GetValues">
            <summary>
            Gets a collection containing the values in the dictionary.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentDictionary`2.Assert(System.Boolean)">
            <summary>
            A helper method for asserts.
            </summary>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Item(`0)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <param name="key">The key of the value to get or set.</param>
            <value>The value associated with the specified key. If the specified key is not found, a get
            operation throws a
            <see cref="T:System.Collections.Generic.KeyNotFoundException"/>, and a set operation creates a new
            element with the specified key.</value>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and
            <paramref name="key"/>
            does not exist in the collection.</exception>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Count">
            <summary>
            Gets the number of key/value pairs contained in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.
            </summary>
            <exception cref="T:System.OverflowException">The dictionary contains too many
            elements.</exception>
            <value>The number of key/value paris contained in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>.</value>
            <remarks>Count has snapshot semantics and represents the number of items in the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>
            at the moment when Count was accessed.</remarks>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.IsEmpty">
            <summary>
            Gets a value that indicates whether the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> is empty.
            </summary>
            <value>true if the <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/> is empty; otherwise,
            false.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Keys">
            <summary>
            Gets a collection containing the keys in the <see
            cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/>.
            </summary>
            <value>An <see cref="T:System.Collections.Generic.ICollection{TKey}"/> containing the keys in the
            <see cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/>.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.Values">
            <summary>
            Gets a collection containing the values in the <see
            cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/>.
            </summary>
            <value>An <see cref="T:System.Collections.Generic.ICollection{TValue}"/> containing the values in
            the
            <see cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/>.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#IsReadOnly">
            <summary>
            Gets a value indicating whether the dictionary is read-only.
            </summary>
            <value>true if the <see cref="T:System.Collections.Generic.ICollection{TKey,TValue}"/> is
            read-only; otherwise, false. For <see
            cref="T:System.Collections.Generic.Dictionary{TKey,TValue}"/>, this property always returns
            false.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsFixedSize">
            <summary>
            Gets a value indicating whether the <see
            cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/> has a fixed size.
            </summary>
            <value>true if the <see cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/> has a
            fixed size; otherwise, false. For <see
            cref="T:System.Collections.Generic.ConcurrentDictionary{TKey,TValue}"/>, this property always
            returns false.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#IsReadOnly">
            <summary>
            Gets a value indicating whether the <see
            cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/> is read-only.
            </summary>
            <value>true if the <see cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/> is
            read-only; otherwise, false. For <see
            cref="T:System.Collections.Generic.ConcurrentDictionary{TKey,TValue}"/>, this property always
            returns false.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Keys">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> containing the keys of the <see
            cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/>.
            </summary>
            <value>An <see cref="T:System.Collections.ICollection"/> containing the keys of the <see
            cref="T:System.Collections.Generic.IDictionary{TKey,TValue}"/>.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Values">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> containing the values in the <see
            cref="T:System.Collections.IDictionary"/>.
            </summary>
            <value>An <see cref="T:System.Collections.ICollection"/> containing the values in the <see
            cref="T:System.Collections.IDictionary"/>.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#IDictionary#Item(System.Object)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <param name="key">The key of the value to get or set.</param>
            <value>The value associated with the specified key, or a null reference (Nothing in Visual Basic)
            if <paramref name="key"/> is not in the dictionary or <paramref name="key"/> is of a type that is
            not assignable to the key type <typeparamref name="TKey"/> of the <see
            cref="T:System.Collections.Generic.ConcurrentDictionary{TKey,TValue}"/>.</value>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is a null reference
            (Nothing in Visual Basic).</exception>
            <exception cref="T:System.ArgumentException">
            A value is being assigned, and <paramref name="key"/> is of a type that is not assignable to the
            key type <typeparamref name="TKey"/> of the <see
            cref="T:System.Collections.Generic.ConcurrentDictionary{TKey,TValue}"/>. -or- A value is being
            assigned, and <paramref name="key"/> is of a type that is not assignable to the value type
            <typeparamref name="TValue"/> of the <see
            cref="T:System.Collections.Generic.ConcurrentDictionary{TKey,TValue}"/>
            </exception>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"/> is
            synchronized with the SyncRoot.
            </summary>
            <value>true if access to the <see cref="T:System.Collections.ICollection"/> is synchronized
            (thread safe); otherwise, false. For <see
            cref="T:System.Collections.Concurrent.ConcurrentDictionary{TKey,TValue}"/>, this property always
            returns false.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see
            cref="T:System.Collections.ICollection"/>. This property is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">The SyncRoot property is not supported.</exception>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentDictionary`2.DefaultConcurrencyLevel">
            <summary>
            The number of concurrent writes for which to optimize by default.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentDictionary`2.Tables">
             <summary>
             Tables that hold the internal state of the ConcurrentDictionary
            
             Wrapping the three tables in a single object allows us to atomically
             replace all tables at once.
             </summary>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentDictionary`2.Node">
            <summary>
            A node in a singly-linked list representing a particular hash table bucket.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentDictionary`2.DictionaryEnumerator">
            <summary>
            A private class to represent enumeration over the dictionary that implements the 
            IDictionaryEnumerator interface.
            </summary>
        </member>
        <member name="T:CoAP.Stack.CoapStack">
            <summary>
            Builds up the stack of CoAP layers
            that process the CoAP protocol.
            </summary>
        </member>
        <member name="M:CoAP.Stack.CoapStack.#ctor(CoAP.ICoapConfig)">
            <summary>
            Instantiates.
            </summary>
            <param name="config"></param>
        </member>
        <member name="P:CoAP.Stack.CoapStack.Executor">
            <summary>
            Sets the <see cref="T:CoAP.Threading.IExecutor"/> for all layers.
            </summary>
        </member>
        <member name="T:CoAP.Request">
            <summary>
            This class describes the functionality of a CoAP Request as
            a subclass of a CoAP Message. It provides:
            1. operations to answer a request by a response using respond()
            2. different ways to handle incoming responses: receiveResponse() or Responsed event
            </summary>
        </member>
        <member name="T:CoAP.Message">
            <summary>
            The class Message models the base class of all CoAP messages.
            CoAP messages are of type <see cref="T:CoAP.Request"/>, <see cref="T:CoAP.Response"/>
            or <see cref="T:CoAP.EmptyMessage"/>, each of which has a <see cref="T:CoAP.MessageType"/>,
            a message identifier <see cref="P:CoAP.Message.ID"/>, a token (0-8 bytes),
            a  collection of <see cref="T:CoAP.Option"/>s and a payload.
            </summary>
        </member>
        <member name="F:CoAP.Message.InvalidID">
            <summary>
            Invalid message ID.
            </summary>
        </member>
        <member name="F:CoAP.Message.None">
            <summary>
            Indicates that no ID has been set.
            </summary>
        </member>
        <member name="M:CoAP.Message.#ctor">
            <summary>
            Instantiates a message.
            </summary>
        </member>
        <member name="M:CoAP.Message.#ctor(CoAP.MessageType)">
            <summary>
            Instantiates a message with the given type.
            </summary>
            <param name="type">the message type</param>
        </member>
        <member name="M:CoAP.Message.#ctor(CoAP.MessageType,System.Int32)">
            <summary>
            Instantiates a message with the given type and code.
            </summary>
            <param name="type">the message type</param>
            <param name="code">the message code</param>
        </member>
        <member name="M:CoAP.Message.SetPayload(System.String)">
            <summary>
            Sets the payload of this CoAP message.
            </summary>
            <param name="payload">The string representation of the payload</param>
        </member>
        <member name="M:CoAP.Message.SetPayload(System.String,System.Int32)">
            <summary>
            Sets the payload of this CoAP message.
            </summary>
            <param name="payload">The string representation of the payload</param>
            <param name="mediaType">The content-type of the payload</param>
        </member>
        <member name="M:CoAP.Message.SetPayload(System.Byte[],System.Int32)">
            <summary>
            Sets the payload of this CoAP message.
            </summary>
            <param name="payload">the payload bytes</param>
            <param name="mediaType">the content-type of the payload</param>
        </member>
        <member name="M:CoAP.Message.Cancel">
            <summary>
            Cancels this message.
            </summary>
        </member>
        <member name="M:CoAP.Message.OnAcknowledged">
            <summary>
            Called when being acknowledged.
            </summary>
        </member>
        <member name="M:CoAP.Message.OnRejected">
            <summary>
            Called when being rejected.
            </summary>
        </member>
        <member name="M:CoAP.Message.OnTimedOut">
            <summary>
            Called when being timed out.
            </summary>
        </member>
        <member name="M:CoAP.Message.OnCanceled">
            <summary>
            Called when being canceled.
            </summary>
        </member>
        <member name="M:CoAP.Message.ToString">
            <summary>
            To string.
            </summary>
        </member>
        <member name="M:CoAP.Message.Equals(System.Object)">
            <summary>
            Equals.
            </summary>
        </member>
        <member name="M:CoAP.Message.GetHashCode">
            <summary>
            Get hash code.
            </summary>
        </member>
        <member name="M:CoAP.Message.AddOption(CoAP.Option)">
            <summary>
            Adds an option to the list of options of this CoAP message.
            </summary>
            <param name="option">the option to add</param>
        </member>
        <member name="M:CoAP.Message.AddOptions(System.Collections.Generic.IEnumerable{CoAP.Option})">
            <summary>
            Adds all option to the list of options of this CoAP message.
            </summary>
            <param name="options">the options to add</param>
        </member>
        <member name="M:CoAP.Message.RemoveOptions(CoAP.OptionType)">
            <summary>
            Removes all options of the given type from this CoAP message.
            </summary>
            <param name="optionType">the type of option to remove</param>
        </member>
        <member name="M:CoAP.Message.GetOptions(CoAP.OptionType)">
            <summary>
            Gets all options of the given type.
            </summary>
            <param name="optionType">the option type</param>
            <returns></returns>
        </member>
        <member name="M:CoAP.Message.SetOption(CoAP.Option)">
            <summary>
            Sets an option.
            </summary>
            <param name="opt">the option to set</param>
        </member>
        <member name="M:CoAP.Message.SetOptions(System.Collections.Generic.IEnumerable{CoAP.Option})">
            <summary>
            Sets all options with the specified option type.
            </summary>
            <param name="options">the options to set</param>
        </member>
        <member name="M:CoAP.Message.HasOption(CoAP.OptionType)">
            <summary>
            Checks if this CoAP message has options of the specified option type.
            </summary>
            <param name="type">the option type</param>
            <returns>rrue if options of the specified type exist</returns>
        </member>
        <member name="M:CoAP.Message.GetFirstOption(CoAP.OptionType)">
            <summary>
            Gets the first option of the specified option type.
            </summary>
            <param name="optionType">the option type</param>
            <returns>the first option of the specified type, or null</returns>
        </member>
        <member name="M:CoAP.Message.GetOptions">
            <summary>
            Gets a sorted list of all options.
            </summary>
            <returns></returns>
        </member>
        <member name="E:CoAP.Message.Retransmitting">
            <summary>
            Occurs when this message is retransmitting.
            </summary>
        </member>
        <member name="E:CoAP.Message.Acknowledged">
            <summary>
            Occurs when this message has been acknowledged by the remote endpoint.
            </summary>
        </member>
        <member name="E:CoAP.Message.Rejected">
            <summary>
            Occurs when this message has been rejected by the remote endpoint.
            </summary>
        </member>
        <member name="E:CoAP.Message.TimedOut">
            <summary>
            Occurs when the client stops retransmitting the message and still has
            not received anything from the remote endpoint.
            </summary>
        </member>
        <member name="E:CoAP.Message.Cancelled">
            <summary>
            Occurs when this message has been canceled.
            </summary>
        </member>
        <member name="P:CoAP.Message.Type">
            <summary>
            Gets or sets the type of this CoAP message.
            </summary>
        </member>
        <member name="P:CoAP.Message.ID">
            <summary>
            Gets or sets the ID of this CoAP message.
            </summary>
        </member>
        <member name="P:CoAP.Message.Code">
            <summary>
            Gets the code of this CoAP message.
            </summary>
        </member>
        <member name="P:CoAP.Message.CodeString">
            <summary>
            Gets the code's string representation of this CoAP message.
            </summary>
        </member>
        <member name="P:CoAP.Message.IsRequest">
            <summary>
            Gets a value that indicates whether this CoAP message is a request message.
            </summary>
        </member>
        <member name="P:CoAP.Message.IsResponse">
            <summary>
            Gets a value that indicates whether this CoAP message is a response message.
            </summary>
        </member>
        <member name="P:CoAP.Message.Token">
            <summary>
            Gets or sets the 0-8 byte token.
            </summary>
        </member>
        <member name="P:CoAP.Message.TokenString">
            <summary>
            Gets the token represented as a string.
            </summary>
        </member>
        <member name="P:CoAP.Message.Destination">
            <summary>
            Gets or sets the destination endpoint.
            </summary>
        </member>
        <member name="P:CoAP.Message.Source">
            <summary>
            Gets or sets the source endpoint.
            </summary>
        </member>
        <member name="P:CoAP.Message.IsAcknowledged">
            <summary>
            Gets or sets a value indicating whether this message has been acknowledged.
            </summary>
        </member>
        <member name="P:CoAP.Message.IsRejected">
            <summary>
            Gets or sets a value indicating whether this message has been rejected.
            </summary>
        </member>
        <member name="P:CoAP.Message.IsTimedOut">
            <summary>
            Gets or sets a value that indicates whether this CoAP message has timed out.
            Confirmable messages in particular might timeout.
            </summary>
        </member>
        <member name="P:CoAP.Message.IsCancelled">
            <summary>
            Gets or sets a value that indicates whether this CoAP message is canceled.
            </summary>
        </member>
        <member name="P:CoAP.Message.Duplicate">
            <summary>
            Gets or sets a value indicating whether this message is a duplicate.
            </summary>
        </member>
        <member name="P:CoAP.Message.Bytes">
            <summary>
            Gets or sets the serialized message as byte array, or null if not serialized yet.
            </summary>
        </member>
        <member name="P:CoAP.Message.Timestamp">
            <summary>
            Gets or sets the timestamp when this message has been received or sent,
            or <see cref="F:System.DateTime.MinValue"/> if neither has happened yet.
            </summary>
        </member>
        <member name="P:CoAP.Message.MaxRetransmit">
            <summary>
            Gets or sets the max times this message should be retransmitted if no ACK received.
            A value of 0 means that the <see cref="P:CoAP.ICoapConfig.MaxRetransmit"/>
            shoud be taken into account, while a negative means NO retransmission.
            The default value is 0.
            </summary>
        </member>
        <member name="P:CoAP.Message.AckTimeout">
            <summary>
            Gets or sets the amount of time in milliseconds after which this message will time out.
            A value of 0 indicates that the time should be decided automatically,
            while a negative that never time out. The default value is 0.
            </summary>
        </member>
        <member name="P:CoAP.Message.PayloadSize">
            <summary>
            Gets the size of the payload of this CoAP message.
            </summary>
        </member>
        <member name="P:CoAP.Message.Payload">
            <summary>
            Gets or sets the payload of this CoAP message.
            </summary>
        </member>
        <member name="P:CoAP.Message.PayloadString">
            <summary>
            Gets or sets the payload of this CoAP message in string representation.
            </summary>
        </member>
        <member name="P:CoAP.Message.IfMatches">
            <summary>
            Gets If-Match options.
            </summary>
        </member>
        <member name="P:CoAP.Message.LocationPath">
            <summary>
            Gets or set the location-path of this CoAP message.
            </summary>
        </member>
        <member name="P:CoAP.Message.ContentType">
            <summary>
            Gets or sets the content-type of this CoAP message.
            </summary>
        </member>
        <member name="P:CoAP.Message.ContentFormat">
            <summary>
            Gets or sets the content-format of this CoAP message,
            same as ContentType, only another name.
            </summary>
        </member>
        <member name="P:CoAP.Message.MaxAge">
            <summary>
            Gets or sets the max-age of this CoAP message.
            </summary>
        </member>
        <member name="P:CoAP.Message.Size1">
            <summary>
            Gets or sets the Size1 option. Be <code>null</code> if not set.
            </summary>
        </member>
        <member name="P:CoAP.Message.Size2">
            <summary>
            Gets or sets the Size2 option. Be <code>null</code> if not set.
            </summary>
        </member>
        <member name="M:CoAP.Request.#ctor(CoAP.Method)">
            <summary>
            Initializes a request message.
            </summary>
        </member>
        <member name="M:CoAP.Request.#ctor(CoAP.Method,System.Boolean)">
            <summary>
            Initializes a request message.
            </summary>
            <param name="method">The method code of the message</param>
            <param name="confirmable">True if the request is Confirmable</param>
        </member>
        <member name="M:CoAP.Request.MarkObserve">
            <summary>
            Sets CoAP's observe option. If the target resource of this request
            responds with a success code and also sets the observe option, it will
            send more responses in the future whenever the resource's state changes.
            </summary>
        </member>
        <member name="M:CoAP.Request.MarkObserveCancel">
            <summary>
            Sets CoAP's observe option to the value of 1 to proactively cancel.
            </summary>
        </member>
        <member name="M:CoAP.Request.GetParameter(System.String)">
            <summary>
            Gets the value of a query parameter as a <code>String</code>,
            or <code>null</code> if the parameter does not exist.
            </summary>
            <param name="name">a <code>String</code> specifying the name of the parameter</param>
            <returns>a <code>String</code> representing the single value of the parameter</returns>
        </member>
        <member name="M:CoAP.Request.Send">
            <summary>
            Sends this message.
            </summary>
        </member>
        <member name="M:CoAP.Request.Send(CoAP.Net.IEndPoint)">
            <summary>
            Sends the request over the specified endpoint.
            </summary>
        </member>
        <member name="M:CoAP.Request.WaitForResponse">
            <summary>
            Wait for a response.
            </summary>
            <exception cref="T:System.Threading.ThreadInterruptedException"></exception>
        </member>
        <member name="M:CoAP.Request.WaitForResponse(System.Int32)">
            <summary>
            Wait for a response.
            </summary>
            <param name="millisecondsTimeout">the maximum time to wait in milliseconds</param>
            <returns>the response, or null if timeout occured</returns>
            <exception cref="T:System.Threading.ThreadInterruptedException"></exception>
        </member>
        <member name="M:CoAP.Request.OnRejected">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Request.OnTimedOut">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Request.OnCanceled">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Request.NewGet">
            <summary>
            Construct a GET request.
            </summary>
        </member>
        <member name="M:CoAP.Request.NewPost">
            <summary>
            Construct a POST request.
            </summary>
        </member>
        <member name="M:CoAP.Request.NewPut">
            <summary>
            Construct a PUT request.
            </summary>
        </member>
        <member name="M:CoAP.Request.NewDelete">
            <summary>
            Construct a DELETE request.
            </summary>
        </member>
        <member name="E:CoAP.Request.Respond">
            <summary>
            Fired when a response arrives.
            </summary>
        </member>
        <member name="E:CoAP.Request.Responding">
            <summary>
            Occurs when a block of response arrives in a blockwise transfer.
            </summary>
        </member>
        <member name="E:CoAP.Request.Reregistering">
            <summary>
            Occurs when a observing request is reregistering.
            </summary>
        </member>
        <member name="P:CoAP.Request.Method">
            <summary>
            Gets the request method.
            </summary>
        </member>
        <member name="P:CoAP.Request.Multicast">
            <summary>
            Gets or sets a value indicating whether this request is a multicast request or not.
            </summary>
        </member>
        <member name="P:CoAP.Request.URI">
            <summary>
            Gets or sets the URI of this CoAP message.
            </summary>
        </member>
        <member name="P:CoAP.Request.Response">
            <summary>
            Gets or sets the response to this request.
            </summary>
        </member>
        <member name="T:CoAP.MessageType">
            <summary>
            Types of CoAP messages.
            </summary>
        </member>
        <member name="F:CoAP.MessageType.Unknown">
            <summary>
            Unknown type.
            </summary>
        </member>
        <member name="F:CoAP.MessageType.CON">
            <summary>
            Confirmable messages require an acknowledgement.
            </summary>
        </member>
        <member name="F:CoAP.MessageType.NON">
            <summary>
            Non-Confirmable messages do not require an acknowledgement.
            </summary>
        </member>
        <member name="F:CoAP.MessageType.ACK">
            <summary>
            Acknowledgement messages acknowledge a specific confirmable message.
            </summary>
        </member>
        <member name="F:CoAP.MessageType.RST">
            <summary>
            Reset messages indicate that a specific confirmable message was received, but some context is missing to properly process it.
            </summary>
        </member>
        <member name="T:CoAP.ICoapConfig">
            <summary>
            Provides configuration for CoAP communication.
            </summary>
        </member>
        <member name="M:CoAP.ICoapConfig.Load(System.String)">
            <summary>
            Loads configuration from a config properties file.
            </summary>
        </member>
        <member name="M:CoAP.ICoapConfig.Store(System.String)">
            <summary>
            Stores the configuration in a config properties file.
            </summary>
        </member>
        <member name="P:CoAP.ICoapConfig.Version">
            <summary>
            Gets the version of CoAP protocol.
            </summary>
        </member>
        <member name="P:CoAP.ICoapConfig.DefaultPort">
            <summary>
            Gets the default CoAP port for normal CoAP communication (not secure).
            </summary>
        </member>
        <member name="P:CoAP.ICoapConfig.DefaultSecurePort">
            <summary>
            Gets the default CoAP port for secure CoAP communication (coaps).
            </summary>
        </member>
        <member name="P:CoAP.ICoapConfig.HttpPort">
            <summary>
            Gets the port which HTTP proxy is on.
            </summary>
        </member>
        <member name="P:CoAP.ICoapConfig.DefaultBlockSize">
            <summary>
            Gets the default preferred size of block in blockwise transfer.
            </summary>
        </member>
        <member name="P:CoAP.ICoapConfig.Spec">
            <summary>
            Gets the specification to apply.
            </summary>
        </member>
        <!-- 对于成员“T:System.Collections.Generic.HashSet`1”忽略有格式错误的 XML 注释 -->
        <member name="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Implementation Notes:
            Since resizes are relatively expensive (require rehashing), this attempts to minimize 
            the need to resize by setting the initial capacity based on size of collection. 
            </summary>
            <param name="collection"></param>
            <param name="comparer"></param>
        </member>
        <!-- 对于成员“M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection{T}#Add(`0)”忽略有格式错误的 XML 注释 -->
        <member name="M:System.Collections.Generic.HashSet`1.Clear">
            <summary>
            Remove all items from this set. This clears the elements but not the underlying 
            buckets and slots array. Follow this call by TrimExcess to release these.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Contains(`0)">
            <summary>
            Checks if this hashset contains the item
            </summary>
            <param name="item">item to check for containment</param>
            <returns>true if item contained; false if not</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy items in this hashset to array, starting at arrayIndex
            </summary>
            <param name="array">array to add items to</param>
            <param name="arrayIndex">index to start at</param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Remove(`0)">
            <summary>
            Remove item from this hashset
            </summary>
            <param name="item">item to remove</param>
            <returns>true if removed; false if not (i.e. if the item wasn't in the HashSet)</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Add(`0)">
            <summary>
            Add item to this HashSet. Returns bool indicating whether item was added (won't be 
            added if already present)
            </summary>
            <param name="item"></param>
            <returns>true if added, false if already present</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Take the union of this HashSet with other. Modifies this set.
            
            Implementation note: GetSuggestedCapacity (to increase capacity in advance avoiding 
            multiple resizes ended up not being useful in practice; quickly gets to the 
            point where it's a wasteful check.
            </summary>
            <param name="other">enumerable with items to add</param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Takes the intersection of this set with other. Modifies this set.
            
            Implementation Notes: 
            We get better perf if other is a hashset using same equality comparer, because we 
            get constant contains check in other. Resulting cost is O(n1) to iterate over this.
            
            If we can't go above route, iterate over the other and mark intersection by checking
            contains in this. Then loop over and delete any unmarked elements. Total cost is n2+n1. 
            
            Attempts to return early based on counts alone, using the property that the 
            intersection of anything with the empty set is the empty set.
            </summary>
            <param name="other">enumerable with items to add </param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove items in other from this set. Modifies this set.
            </summary>
            <param name="other">enumerable with items to remove</param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Takes symmetric difference (XOR) with other and this set. Modifies this set.
            </summary>
            <param name="other">enumerable with items to XOR</param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this is a subset of other.
            
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it's a subset of anything, including the empty set
            2. If other has unique elements according to this equality comparer, and this has more
            elements than other, then it can't be a subset.
            
            Furthermore, if other is a hashset using the same equality comparer, we can use a 
            faster element-wise check.
            </summary>
            <param name="other"></param>
            <returns>true if this is a subset of other; false if not</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this is a proper subset of other (i.e. strictly contained in)
            
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it's a proper subset of a set that contains at least
            one element, but it's not a proper subset of the empty set.
            2. If other has unique elements according to this equality comparer, and this has >=
            the number of elements in other, then this can't be a proper subset.
            
            Furthermore, if other is a hashset using the same equality comparer, we can use a 
            faster element-wise check.
            </summary>
            <param name="other"></param>
            <returns>true if this is a proper subset of other; false if not</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this is a superset of other
            
            Implementation Notes:
            The following properties are used up-front to avoid element-wise checks:
            1. If other has no elements (it's the empty set), then this is a superset, even if this
            is also the empty set.
            2. If other has unique elements according to this equality comparer, and this has less 
            than the number of elements in other, then this can't be a superset
            
            </summary>
            <param name="other"></param>
            <returns>true if this is a superset of other; false if not</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this is a proper superset of other (i.e. other strictly contained in this)
            
            Implementation Notes: 
            This is slightly more complicated than above because we have to keep track if there
            was at least one element not contained in other.
            
            The following properties are used up-front to avoid element-wise checks:
            1. If this is the empty set, then it can't be a proper superset of any set, even if 
            other is the empty set.
            2. If other is an empty set and this contains at least 1 element, then this is a proper
            superset.
            3. If other has unique elements according to this equality comparer, and other's count
            is greater than or equal to this count, then this can't be a proper superset
            
            Furthermore, if other has unique elements according to this equality comparer, we can
            use a faster element-wise check.
            </summary>
            <param name="other"></param>
            <returns>true if this is a proper superset of other; false if not</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this set overlaps other (i.e. they share at least one item)
            </summary>
            <param name="other"></param>
            <returns>true if these have at least one common element; false if disjoint</returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this and other contain the same elements. This is set equality: 
            duplicates and order are ignored
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})">
            <summary>
            Remove elements that match specified predicate. Returns the number of elements removed
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.TrimExcess">
            <summary>
            Sets the capacity of this list to the size of the list (rounded up to nearest prime),
            unless count is 0, in which case we release references.
            
            This method can be used to minimize a list's memory overhead once it is known that no
            new elements will be added to the list. To completely clear a list and release all 
            memory referenced by the list, execute the following statements:
            
            list.Clear();
            list.TrimExcess(); 
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.Initialize(System.Int32)">
            <summary>
            Initializes buckets and slots arrays. Uses suggested capacity by finding next prime
            greater than or equal to capacity.
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IncreaseCapacity">
            <summary>
            Expand to new capacity. New capacity is next prime greater than or equal to suggested 
            size. This is called when the underlying array is filled. This performs no 
            defragmentation, allowing faster execution; note that this is reasonable since 
            AddIfNotPresent attempts to insert new elements in re-opened spots.
            </summary>
            <param name="sizeSuggestion"></param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.SetCapacity(System.Int32,System.Boolean)">
            <summary>
            Set the underlying buckets array to size newSize and rehash.  Note that newSize
            *must* be a prime.  It is very likely that you want to call IncreaseCapacity()
            instead of this method.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.AddIfNotPresent(`0)">
            <summary>
            Adds value to HashSet if not contained already
            Returns true if added and false if already present
            </summary>
            <param name="value">value to find</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.ContainsAllElements(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this contains of other's elements. Iterates over other's elements and 
            returns false as soon as it finds an element in other that's not in this.
            Used by SupersetOf, ProperSupersetOf, and SetEquals.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IsSubsetOfHashSetWithSameEC(System.Collections.Generic.HashSet{`0})">
             <summary>
             Implementation Notes:
             If other is a hashset and is using same equality comparer, then checking subset is 
             faster. Simply check that each element in this is in other.
             
             Note: if other doesn't use same equality comparer, then Contains check is invalid,
             which is why callers must take are of this.
             
             If callers are concerned about whether this is a proper subset, they take care of that.
            
             </summary>
             <param name="other"></param>
             <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IntersectWithHashSetWithSameEC(System.Collections.Generic.HashSet{`0})">
            <summary>
            If other is a hashset that uses same equality comparer, intersect is much faster 
            because we can use other's Contains
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.IntersectWithEnumerable(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Iterate over other. If contained in this, mark an element in bit array corresponding to
            its position in _slots. If anything is unmarked (in bit array), remove it.
            
            This attempts to allocate on the stack, if below StackAllocThreshold.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.InternalIndexOf(`0)">
            <summary>
            Used internally by set operations which have to rely on bit array marking. This is like
            Contains but returns index in slots array. 
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.SymmetricExceptWithUniqueHashSet(System.Collections.Generic.HashSet{`0})">
            <summary>
            if other is a set, we can assume it doesn't have duplicate elements, so use this
            technique: if can't remove, then it wasn't present in this set, so add.
            
            As with other methods, callers take care of ensuring that other is a hashset using the
            same equality comparer.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.SymmetricExceptWithEnumerable(System.Collections.Generic.IEnumerable{`0})">
             <summary>
             Implementation notes:
             
             Used for symmetric except when other isn't a HashSet. This is more tedious because 
             other may contain duplicates. HashSet technique could fail in these situations:
             1. Other has a duplicate that's not in this: HashSet technique would add then 
             remove it.
             2. Other has a duplicate that's in this: HashSet technique would remove then add it
             back.
             In general, its presence would be toggled each time it appears in other. 
             
             This technique uses bit marking to indicate whether to add/remove the item. If already
             present in collection, it will get marked for deletion. If added from other, it will
             get marked as something not to remove.
            
             </summary>
             <param name="other"></param>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.AddOrGetLocation(`0,System.Int32@)">
            <summary>
            Add if not already in hashset. Returns an out param indicating index where added. This 
            is used by SymmetricExcept because it needs to know the following things:
            - whether the item was already present in the collection or added from other
            - where it's located (if already present, it will get marked for removal, otherwise
            marked for keeping)
            </summary>
            <param name="value"></param>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.CheckUniqueAndUnfoundElements(System.Collections.Generic.IEnumerable{`0},System.Boolean)">
            <summary>
            Determines counts that can be used to determine equality, subset, and superset. This
            is only used when other is an IEnumerable and not a HashSet. If other is a HashSet
            these properties can be checked faster without use of marking because we can assume 
            other has no duplicates.
            
            The following count checks are performed by callers:
            1. Equals: checks if unfoundCount = 0 and uniqueFoundCount = _count; i.e. everything 
            in other is in this and everything in this is in other
            2. Subset: checks if unfoundCount >= 0 and uniqueFoundCount = _count; i.e. other may
            have elements not in this and everything in this is in other
            3. Proper subset: checks if unfoundCount > 0 and uniqueFoundCount = _count; i.e
            other must have at least one element not in this and everything in this is in other
            4. Proper superset: checks if unfound count = 0 and uniqueFoundCount strictly less
            than _count; i.e. everything in other was in this and this had at least one element
            not contained in other.
            
            An earlier implementation used delegates to perform these checks rather than returning
            an ElementCount struct; however this was changed due to the perf overhead of delegates.
            </summary>
            <param name="other"></param>
            <param name="returnIfUnfound">Allows us to finish faster for equals and proper superset
            because unfoundCount must be 0.</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.ToArray">
            <summary>
            Copies this to an array. Used for DebugView
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.HashSetEquals(System.Collections.Generic.HashSet{`0},System.Collections.Generic.HashSet{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Internal method used for HashSetEqualityComparer. Compares set1 and set2 according 
            to specified comparer.
            
            Because items are hashed according to a specific equality comparer, we have to resort
            to n^2 search if they're using different equality comparers.
            </summary>
            <param name="set1"></param>
            <param name="set2"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.AreEqualityComparersEqual(System.Collections.Generic.HashSet{`0},System.Collections.Generic.HashSet{`0})">
            <summary>
            Checks if equality comparers are equal. This is used for algorithms that can
            speed up if it knows the other item has unique elements. I.e. if they're using 
            different equality comparers, then uniqueness assumption between sets break.
            </summary>
            <param name="set1"></param>
            <param name="set2"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.HashSet`1.InternalGetHashCode(`0)">
            <summary>
            Workaround Comparers that throw ArgumentNullException for GetHashCode(null).
            </summary>
            <param name="item"></param>
            <returns>hash code</returns>
        </member>
        <member name="P:System.Collections.Generic.HashSet`1.Count">
            <summary>
            Number of elements in this hashset
            </summary>
        </member>
        <member name="P:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Whether this is readonly
            </summary>
        </member>
        <member name="P:System.Collections.Generic.HashSet`1.Comparer">
            <summary>
            Gets the IEqualityComparer that is used to determine equality of keys for 
            the HashSet.
            </summary>
        </member>
        <member name="T:CoAP.Threading.NoThreadingExecutor">
            <summary>
            This <see cref="T:CoAP.Threading.IExecutor"/> will execute tasks immediately in the calling thread.
            No threading will be used.
            </summary>
        </member>
        <member name="T:CoAP.Threading.IExecutor">
            <summary>
            Provides methods to execute tasks.
            </summary>
        </member>
        <member name="M:CoAP.Threading.IExecutor.Start(CoAP.Action)">
            <summary>
            Starts a task without parameter.
            </summary>
            <param name="task">the task to run</param>
        </member>
        <member name="M:CoAP.Threading.IExecutor.Start(System.Action{System.Object},System.Object)">
            <summary>
            Starts a task with a parameter.
            </summary>
            <param name="task">the task to run</param>
            <param name="obj">the parameter to be passed into the task</param>
        </member>
        <member name="M:CoAP.Threading.NoThreadingExecutor.Start(CoAP.Action)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Threading.NoThreadingExecutor.Start(System.Action{System.Object},System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:CoAP.Net.IMessageDeliverer">
            <summary>
            Provides methods for delivering inbound CoAP messages to an appropriate processor.
            </summary>
        </member>
        <member name="M:CoAP.Net.IMessageDeliverer.DeliverRequest(CoAP.Net.Exchange)">
            <summary>
            Delivers an inbound CoAP request to an appropriate resource.
            </summary>
            <param name="exchange"> the exchange containing the inbound <see cref="T:CoAP.Request"/></param>
        </member>
        <member name="M:CoAP.Net.IMessageDeliverer.DeliverResponse(CoAP.Net.Exchange,CoAP.Response)">
            <summary>
            Delivers an inbound CoAP response message to its corresponding request.
            </summary>
            <param name="exchange">the exchange containing the originating CoAP request</param>
            <param name="response">the inbound CoAP response message</param>
        </member>
        <member name="M:CoAP.Net.ClientMessageDeliverer.DeliverRequest(CoAP.Net.Exchange)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.ClientMessageDeliverer.DeliverResponse(CoAP.Net.Exchange,CoAP.Response)">
            <inheritdoc/>
        </member>
        <member name="T:CoAP.Codec.MessageEncoder">
            <summary>
            Base class for message encoders.
            </summary>
        </member>
        <member name="M:CoAP.Codec.MessageEncoder.Encode(CoAP.Request)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Codec.MessageEncoder.Encode(CoAP.Response)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Codec.MessageEncoder.Encode(CoAP.EmptyMessage)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Codec.MessageEncoder.Encode(CoAP.Message)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Codec.MessageEncoder.Serialize(CoAP.Codec.DatagramWriter,CoAP.Message,System.Int32)">
            <summary>
            Serializes a message.
            </summary>
            <param name="writer">the writer</param>
            <param name="message">the message to write</param>
            <param name="code">the code</param>
        </member>
        <member name="T:System.Collections.Concurrent.IProducerConsumerCollection`1">
            <summary>
            Defines methods to manipulate thread-safe collections intended for producer/consumer usage.
            </summary>
            <typeparam name="T">Specifies the type of elements in the collection.</typeparam>
            <remarks>
            All implementations of this interface must enable all members of this interface
            to be used concurrently from multiple threads.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/> to
            an
            <see cref="T:System.Array"/>, starting at a specified index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of
            the elements copied from the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>.
            The array must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying
            begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in
            Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            zero.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="index"/> is equal to or greater than the
            length of the <paramref name="array"/>
            -or- The number of elements in the source <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> is greater than the
            available space from <paramref name="index"/> to the end of the destination <paramref name="array"/>.
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.TryAdd(`0)">
            <summary>
            Attempts to add an object to the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>.
            </summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>.</param>
            <returns>true if the object was added successfully; otherwise, false.</returns>
            <exception cref="T:System.ArgumentException">The <paramref name="item"/> was invalid for this collection.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.TryTake(`0@)">
            <summary>
            Attempts to remove and return an object from the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>.
            </summary>
            <param name="item">
            When this method returns, if the object was removed and returned successfully, <paramref name="item"/> contains the removed object. If no object was available to be removed, the value is
            unspecified.
            </param>
            <returns>true if an object was removed and returned successfully; otherwise, false.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.IProducerConsumerCollection`1.ToArray">
            <summary>
            Copies the elements contained in the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/> to a new array.
            </summary>
            <returns>A new array containing the elements copied from the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1"/>.</returns>
        </member>
        <member name="T:System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1">
            <summary>
            A debugger view of the IProducerConsumerCollection that makes it simple to browse the
            collection's contents at a point in time.
            </summary>
            <typeparam name="T">The type of elements stored within.</typeparam>
        </member>
        <member name="M:System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
            <summary>
            Constructs a new debugger view object for the provided collection object.
            </summary>
            <param name="collection">A collection to browse in the debugger.</param>
        </member>
        <member name="P:System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1.Items">
            <summary>
            Returns a snapshot of the underlying collection's elements.
            </summary>
        </member>
        <member name="T:CoAP.Threading.Executors">
            <summary>
            Executors.
            </summary>
        </member>
        <member name="F:CoAP.Threading.Executors.NoThreading">
            <summary>
            This <see cref="T:CoAP.Threading.IExecutor"/> will execute tasks immediately in the calling thread.
            </summary>
        </member>
        <member name="F:CoAP.Threading.Executors.Default">
            <summary>
            The default <see cref="T:CoAP.Threading.IExecutor"/> based on <see cref="T:System.Threading.ThreadPool"/>.
            </summary>
        </member>
        <member name="T:CoAP.Server.Resources.ResourceAttributes">
            <summary>
            Wraps different attributes that the CoAP protocol defines
            such as title, resource type or interface description. These attributes will
            also be included in the link description of the resource they belong to. For
            example, if a title was specified, the link description for a sensor resource
            might look like this <code>&lt;/sensors&gt;;title="Sensor Index"</code>.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.ResourceAttributes.AddResourceType(System.String)">
            <summary>
            Adds a resource type.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.ResourceAttributes.GetResourceTypes">
            <summary>
            Gets all resource types.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.ResourceAttributes.ClearResourceTypes">
            <summary>
            Clears all resource types.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.ResourceAttributes.AddInterfaceDescription(System.String)">
            <summary>
            Adds an interface description.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.ResourceAttributes.GetInterfaceDescriptions">
            <summary>
            Gets all interface descriptions.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.ResourceAttributes.ClearInterfaceDescriptions">
            <summary>
            Clears all interface descriptions.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.ResourceAttributes.AddContentType(System.Int32)">
            <summary>
            Adds a content type specified by an integer.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.ResourceAttributes.GetContentTypes">
            <summary>
            Gets all content types.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.ResourceAttributes.ClearContentTypes">
            <summary>
            Clears all content types.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.ResourceAttributes.Contains(System.String)">
            <summary>
            Returns <tt>true</tt> if this object contains the specified attribute.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.ResourceAttributes.Add(System.String)">
            <summary>
            Adds an arbitrary attribute with no value.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.ResourceAttributes.Add(System.String,System.String)">
            <summary>
            Adds the specified value to the other values of the specified attribute.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.ResourceAttributes.Set(System.String,System.String)">
            <summary>
            Replaces the value for the specified attribute with the specified value.
            If another value has been set for the attribute name, it will be removed.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.ResourceAttributes.GetValues(System.String)">
            <summary>
            Gets all values for the specified attribute.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.ResourceAttributes.Clear(System.String)">
            <summary>
            Removes all values for the specified attribute.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.ResourceAttributes.Count">
            <summary>
            Gets the number of attributes.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.ResourceAttributes.Keys">
            <summary>
            Gets all the attribute names.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.ResourceAttributes.Title">
            <summary>
            Gets the resource title.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.ResourceAttributes.Observable">
            <summary>
            Gets or sets a value indicating if the resource is observable.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.ResourceAttributes.MaximumSizeEstimate">
            <summary>
            Gets or sets the maximum size estimate.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.ResourceAttributes.MaximumSizeEstimateString">
            <summary>
            Gets or sets the maximum size estimate.
            </summary>
        </member>
        <member name="T:CoAP.Response">
            <summary>
            Represents a CoAP response to a CoAP request.
            A response is either a piggy-backed response with type ACK
            or a separate response with type CON or NON.
            </summary>
        </member>
        <member name="M:CoAP.Response.#ctor(CoAP.StatusCode)">
            <summary>
            Initializes a response message.
            </summary>
            <param name="code">The code of this response</param>
        </member>
        <member name="M:CoAP.Response.CreateResponse(CoAP.Request,CoAP.StatusCode)">
            <summary>
            Creates a response to the specified request with the specified response code.
            The destination endpoint of the response is the source endpoint of the request.
            The response has the same token as the request.
            Type and ID are usually set automatically by the <see cref="T:CoAP.Stack.ReliabilityLayer"/>.
            </summary>
        </member>
        <member name="P:CoAP.Response.StatusCode">
            <summary>
            Gets the response status code.
            </summary>
        </member>
        <member name="P:CoAP.Response.RTT">
            <summary>
            Gets the Round-Trip Time of this response.
            </summary>
        </member>
        <member name="P:CoAP.Response.Last">
            <summary>
            Gets or sets a value indicating whether this response is the last response of an exchange.
            </summary>
        </member>
        <member name="T:CoAP.CoapConstants">
            <summary>
            Constants defined for CoAP protocol
            </summary>
        </member>
        <member name="F:CoAP.CoapConstants.Version">
            <summary>
            RFC 7252 CoAP version.
            </summary>
        </member>
        <member name="F:CoAP.CoapConstants.UriScheme">
            <summary>
            The CoAP URI scheme.
            </summary>
        </member>
        <member name="F:CoAP.CoapConstants.SecureUriScheme">
            <summary>
            The CoAPS URI scheme.
            </summary>
        </member>
        <member name="F:CoAP.CoapConstants.DefaultPort">
            <summary>
            The default CoAP port for normal CoAP communication (not secure).
            </summary>
        </member>
        <member name="F:CoAP.CoapConstants.DefaultSecurePort">
            <summary>
            The default CoAP port for secure CoAP communication (coaps).
            </summary>
        </member>
        <member name="F:CoAP.CoapConstants.AckTimeout">
            <summary>
            The initial time (ms) for a CoAP message
            </summary>
        </member>
        <member name="F:CoAP.CoapConstants.AckRandomFactor">
            <summary>
            The initial timeout is set
            to a random number between RESPONSE_TIMEOUT and (RESPONSE_TIMEOUT *
            RESPONSE_RANDOM_FACTOR)
            </summary>
        </member>
        <member name="F:CoAP.CoapConstants.MaxRetransmit">
            <summary>
            The max time that a message would be retransmitted
            </summary>
        </member>
        <member name="F:CoAP.CoapConstants.DefaultBlockSize">
            <summary>
            Default block size used for block-wise transfers
            </summary>
        </member>
        <member name="F:CoAP.CoapConstants.DefaultWellKnownURI">
            <summary>
            Default URI for wellknown resource
            </summary>
        </member>
        <member name="F:CoAP.CoapConstants.ObservingRefreshInterval">
            <summary>
            The number of notifications until a CON notification will be used.
            </summary>
        </member>
        <member name="F:CoAP.CoapConstants.RequestCodeLowerBound">
            <summary>
            The lowest value of a request code.
            </summary>
        </member>
        <member name="F:CoAP.CoapConstants.RequestCodeUpperBound">
            <summary>
            The highest value of a request code.
            </summary>
        </member>
        <member name="F:CoAP.CoapConstants.ResponseCodeLowerBound">
            <summary>
            The lowest value of a response code.
            </summary>
        </member>
        <member name="F:CoAP.CoapConstants.ResponseCodeUpperBound">
            <summary>
            The highest value of a response code.
            </summary>
        </member>
        <member name="T:CoAP.Util.Utils">
            <summary>
            Utility methods.
            </summary>
        </member>
        <member name="M:CoAP.Util.Utils.InsertionSort``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
            <summary>
            Insertion sort, to make the options list stably ordered.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">the list to sort</param>
            <param name="comparison">the delegate for comparing</param>
        </member>
        <member name="M:CoAP.Util.Utils.AreSequenceEqualTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Checks if all items in both of the two enumerables are equal.
            </summary>
        </member>
        <member name="M:CoAP.Util.Utils.AreSequenceEqualTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Checks if all items in both of the two enumerables are equal.
            </summary>
        </member>
        <member name="M:CoAP.Util.Utils.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            Finds the first matched item.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source">the source to search</param>
            <param name="condition">the condition delegate</param>
            <returns>the item found, or null if none is matched</returns>
        </member>
        <member name="M:CoAP.Util.Utils.Contains``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            Checks if matched item exists.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source">the source to search</param>
            <param name="condition">the condition delegate</param>
            <returns>true if exists any matched item, otherwise false</returns>
        </member>
        <member name="M:CoAP.Util.Utils.ToString(CoAP.Message)">
            <summary>
            Stringify a message.
            </summary>
        </member>
        <member name="M:CoAP.Util.Utils.OptionsToString(CoAP.Message)">
            <summary>
            Stringify options in a message.
            </summary>
        </member>
        <member name="M:CoAP.Util.Utils.ToString``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Stringify an enumerable.
            </summary>
        </member>
        <member name="M:CoAP.Util.Utils.ToString``1(System.Collections.Generic.IEnumerable{``0},CoAP.Func{``0,System.String})">
            <summary>
            Stringify an enumerable.
            </summary>
        </member>
        <member name="M:CoAP.Util.Utils.Put``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``0,``1)">
            <summary>
            Puts a value associated with a key into a ConcurrentDictionary,
            and returns the old value, or null if not exists.
            </summary>
        </member>
        <member name="T:CoAP.Server.Resources.CoapExchange">
            <summary>
            Represents an exchange of a CoAP request and response and
            provides a user-friendly API to subclasses of <see cref="T:CoAP.Server.Resources.Resource"/>
            for responding to requests.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.CoapExchange.#ctor(CoAP.Net.Exchange,CoAP.Server.Resources.Resource)">
            <summary>
            Constructs a new CoAP Exchange object representing
            the specified exchange and resource.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.CoapExchange.Accept">
            <summary>
            Accepts the exchange.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.CoapExchange.Reject">
            <summary>
            Rejects the exchange.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.CoapExchange.Respond(CoAP.StatusCode)">
            <summary>
            Responds the specified response code and no payload.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.CoapExchange.Respond(System.String)">
            <summary>
            Responds with code 2.05 (Content) and the specified payload.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.CoapExchange.Respond(CoAP.StatusCode,System.String)">
            <summary>
            Responds with the specified response code and payload.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.CoapExchange.Respond(CoAP.StatusCode,System.Byte[])">
            <summary>
            Responds with the specified response code and payload.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.CoapExchange.Respond(CoAP.StatusCode,System.Byte[],System.Int32)">
            <summary>
            Responds with the specified response code, payload and content-type.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.CoapExchange.Respond(CoAP.StatusCode,System.String,System.Int32)">
            <summary>
            Responds with the specified response code, payload and content-type.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.CoapExchange.Respond(CoAP.Response)">
            <summary>
            Responds Respond with the specified response.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.CoapExchange.Request">
            <summary>
            Gets the request.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.CoapExchange.LocationPath">
            <summary>
            Gets or sets the Location-Path for the response.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.CoapExchange.LocationQuery">
            <summary>
            Gets or sets the Location-Query for the response.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.CoapExchange.MaxAge">
            <summary>
            Gets or sets the Max-Age for the response body.
            </summary>
        </member>
        <member name="P:CoAP.Server.Resources.CoapExchange.ETag">
            <summary>
            Gets or sets the ETag for the response.
            </summary>
        </member>
        <member name="T:CoAP.Observe.ReregisterEventArgs">
            <summary>
            Represents an event when a observing request is reregistering.
            </summary>
        </member>
        <member name="M:CoAP.Observe.ReregisterEventArgs.#ctor(CoAP.Request)">
            <summary>
            Instantiates.
            </summary>
        </member>
        <member name="P:CoAP.Observe.ReregisterEventArgs.RefreshRequest">
            <summary>
            Gets the request sent to refresh an observation.
            </summary>
        </member>
        <member name="T:CoAP.Observe.ObserveRelation">
            <summary>
            Represents a relation between a client endpoint and a resource on this server.
            </summary>
        </member>
        <member name="F:CoAP.Observe.ObserveRelation._notifications">
            <summary>
            The notifications that have been sent, so they can be removed from the Matcher
            </summary>
        </member>
        <member name="M:CoAP.Observe.ObserveRelation.#ctor(CoAP.ICoapConfig,CoAP.Observe.ObservingEndpoint,CoAP.Server.Resources.IResource,CoAP.Net.Exchange)">
            <summary>
            Constructs a new observe relation.
            </summary>
            <param name="config">the config</param>
            <param name="endpoint">the observing endpoint</param>
            <param name="resource">the observed resource</param>
            <param name="exchange">the exchange that tries to establish the observe relation</param>
        </member>
        <member name="M:CoAP.Observe.ObserveRelation.Cancel">
            <summary>
            Cancel this observe relation.
            </summary>
        </member>
        <member name="M:CoAP.Observe.ObserveRelation.CancelAll">
            <summary>
            Cancel all observer relations that this server has
            established with this's realtion's endpoint.
            </summary>
        </member>
        <member name="M:CoAP.Observe.ObserveRelation.NotifyObservers">
            <summary>
            Notifies the observing endpoint that the resource has been changed.
            </summary>
        </member>
        <member name="P:CoAP.Observe.ObserveRelation.Resource">
            <summary>
            Gets the resource.
            </summary>
        </member>
        <member name="P:CoAP.Observe.ObserveRelation.Exchange">
            <summary>
            Gets the exchange.
            </summary>
        </member>
        <member name="P:CoAP.Observe.ObserveRelation.Source">
            <summary>
            Gets the source endpoint of the observing endpoint.
            </summary>
        </member>
        <member name="P:CoAP.Observe.ObserveRelation.Established">
            <summary>
            Gets or sets a value indicating if this relation has been established.
            </summary>
        </member>
        <member name="T:CoAP.Observe.ObserveManager">
            <summary>
            The observe manager holds a mapping of endpoint addresses to
            <see cref="T:CoAP.Observe.ObservingEndpoint"/>s. It makes sure that there be only one
            ObservingEndpoint that represents the observe relations from one endpoint to
            this server. This important in case we want to cancel all relations to a
            specific endpoint, e.g., when a confirmable notification timeouts.
            <remarks>
            Notice that each server has its own ObserveManager. If a server binds to
            multiple endpoints, the ObserveManager keeps the observe relations for all of
            them.
            </remarks>
            </summary>
        </member>
        <member name="M:CoAP.Observe.ObserveManager.#ctor">
            <summary>
            Constructs a new observe manager.
            </summary>
        </member>
        <member name="M:CoAP.Observe.ObserveManager.FindObservingEndpoint(System.Net.EndPoint)">
            <summary>
            Finds the ObservingEndpoint for the specified endpoint address
            or create a new one if none exists yet.
            </summary>
        </member>
        <member name="M:CoAP.Observe.ObserveManager.GetObservingEndpoint(System.Net.EndPoint)">
            <summary>
            Returns the ObservingEndpoint for the specified endpoint address
            or null if none exists.
            </summary>
        </member>
        <member name="T:CoAP.Log.NopLogManager">
            <summary>
            A <see cref="T:CoAP.Log.ILogManager"/> which always returns the unique instance of
            a direct NOP (no operation) logger.
            </summary>
        </member>
        <member name="F:CoAP.Log.NopLogManager.Instance">
            <summary>
            The singleton instance.
            </summary>
        </member>
        <member name="M:CoAP.Log.NopLogManager.GetLogger(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Log.NopLogManager.GetLogger(System.String)">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Net.EndPointManager.Draft03">
            <summary>
            <see cref="T:CoAP.Net.IEndPoint"/> with draft-ietf-core-coap-03.
            </summary>
        </member>
        <member name="P:CoAP.Net.EndPointManager.Draft08">
            <summary>
            <see cref="T:CoAP.Net.IEndPoint"/> with draft-ietf-core-coap-08.
            </summary>
        </member>
        <member name="P:CoAP.Net.EndPointManager.Draft12">
            <summary>
            <see cref="T:CoAP.Net.IEndPoint"/> with draft-ietf-core-coap-12.
            </summary>
        </member>
        <member name="P:CoAP.Net.EndPointManager.Draft13">
            <summary>
            <see cref="T:CoAP.Net.IEndPoint"/> with draft-ietf-core-coap-13.
            </summary>
        </member>
        <member name="P:CoAP.Net.EndPointManager.Draft18">
            <summary>
            <see cref="T:CoAP.Net.IEndPoint"/> with draft-ietf-core-coap-18.
            </summary>
        </member>
        <member name="P:CoAP.Net.EndPointManager.RFC7252">
            <summary>
            <see cref="T:CoAP.Net.IEndPoint"/> with RFC 7252.
            </summary>
        </member>
        <member name="T:CoAP.Net.CoAPEndPoint">
            <summary>
            EndPoint encapsulates the stack that executes the CoAP protocol.
            </summary>
        </member>
        <member name="M:CoAP.IOutbox.SendRequest(CoAP.Net.Exchange,CoAP.Request)">
            <summary>
            Sends the specified request over the connector that the stack is connected to.
            </summary>
        </member>
        <member name="M:CoAP.IOutbox.SendResponse(CoAP.Net.Exchange,CoAP.Response)">
            <summary>
            Sends the specified response over the connector that the stack is connected to.
            </summary>
        </member>
        <member name="M:CoAP.IOutbox.SendEmptyMessage(CoAP.Net.Exchange,CoAP.EmptyMessage)">
            <summary>
            Sends the specified empty message over the connector that the stack is connected to.
            </summary>
        </member>
        <member name="M:CoAP.Net.CoAPEndPoint.#ctor">
            <summary>
            Instantiates a new endpoint.
            </summary>
        </member>
        <member name="M:CoAP.Net.CoAPEndPoint.#ctor(CoAP.ICoapConfig)">
            <summary>
            Instantiates a new endpoint with the specified configuration.
            </summary>
        </member>
        <member name="M:CoAP.Net.CoAPEndPoint.#ctor(System.Int32)">
            <summary>
            Instantiates a new endpoint with the specified port.
            </summary>
        </member>
        <member name="M:CoAP.Net.CoAPEndPoint.#ctor(System.Net.EndPoint)">
            <summary>
            Instantiates a new endpoint with the
            specified <see cref="T:System.Net.EndPoint"/>.
            </summary>
        </member>
        <member name="M:CoAP.Net.CoAPEndPoint.#ctor(System.Int32,CoAP.ICoapConfig)">
            <summary>
            Instantiates a new endpoint with the
            specified port and configuration.
            </summary>
        </member>
        <member name="M:CoAP.Net.CoAPEndPoint.#ctor(System.Net.EndPoint,CoAP.ICoapConfig)">
            <summary>
            Instantiates a new endpoint with the
            specified <see cref="T:System.Net.EndPoint"/> and configuration.
            </summary>
        </member>
        <member name="M:CoAP.Net.CoAPEndPoint.#ctor(CoAP.Channel.IChannel,CoAP.ICoapConfig)">
            <summary>
            Instantiates a new endpoint with the
            specified channel and configuration.
            </summary>
        </member>
        <member name="M:CoAP.Net.CoAPEndPoint.Start">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.CoAPEndPoint.Stop">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.CoAPEndPoint.Clear">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.CoAPEndPoint.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.CoAPEndPoint.SendRequest(CoAP.Request)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.CoAPEndPoint.SendResponse(CoAP.Net.Exchange,CoAP.Response)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.CoAPEndPoint.SendEmptyMessage(CoAP.Net.Exchange,CoAP.EmptyMessage)">
            <inheritdoc/>
        </member>
        <member name="E:CoAP.Net.CoAPEndPoint.SendingRequest">
            <inheritdoc/>
        </member>
        <member name="E:CoAP.Net.CoAPEndPoint.SendingResponse">
            <inheritdoc/>
        </member>
        <member name="E:CoAP.Net.CoAPEndPoint.SendingEmptyMessage">
            <inheritdoc/>
        </member>
        <member name="E:CoAP.Net.CoAPEndPoint.ReceivingRequest">
            <inheritdoc/>
        </member>
        <member name="E:CoAP.Net.CoAPEndPoint.ReceivingResponse">
            <inheritdoc/>
        </member>
        <member name="E:CoAP.Net.CoAPEndPoint.ReceivingEmptyMessage">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Net.CoAPEndPoint.Config">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Net.CoAPEndPoint.LocalEndPoint">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Net.CoAPEndPoint.MessageDeliverer">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Net.CoAPEndPoint.Outbox">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Net.CoAPEndPoint.Running">
            <inheritdoc/>
        </member>
        <member name="T:CoAP.CoapObserveRelation">
            <summary>
            Represents a CoAP observe relation between a CoAP client and a resource on a server.
            Provides a simple API to check whether a relation has successfully established and
            to cancel or refresh the relation.
            </summary>
        </member>
        <member name="T:CoAP.Channel.IPAddressExtensions">
            <summary>
            Extension methods for <see cref="T:System.Net.IPAddress"/>.
            </summary>
        </member>
        <member name="M:CoAP.Channel.IPAddressExtensions.IsIPv4MappedToIPv6(System.Net.IPAddress)">
            <summary>
            Checks whether the IP address is an IPv4-mapped IPv6 address.
            </summary>
            <param name="address">the <see cref="T:System.Net.IPAddress"/> object to check</param>
            <returns>true if the IP address is an IPv4-mapped IPv6 address; otherwise, false.</returns>
        </member>
        <member name="M:CoAP.Channel.IPAddressExtensions.MapToIPv4(System.Net.IPAddress)">
            <summary>
            Maps the <see cref="T:System.Net.IPAddress"/> object to an IPv4 address.
            </summary>
            <param name="address">the <see cref="T:System.Net.IPAddress"/> object</param>
            <returns>An IPv4 address.</returns>
        </member>
        <member name="M:CoAP.Channel.IPAddressExtensions.MapToIPv6(System.Net.IPAddress)">
            <summary>
            Maps the <see cref="T:System.Net.IPAddress"/> object to an IPv6 address.
            </summary>
            <param name="address">the <see cref="T:System.Net.IPAddress"/> object</param>
            <returns>An IPv6 address.</returns>
        </member>
        <member name="T:CoAP.Log.LogManager">
            <summary>
            Log manager.
            </summary>
        </member>
        <member name="M:CoAP.Log.LogManager.GetLogger(System.Type)">
            <summary>
            Gets a logger for the given type.
            </summary>
        </member>
        <member name="M:CoAP.Log.LogManager.GetLogger(System.String)">
            <summary>
            Gets a logger for the given type name.
            </summary>
        </member>
        <member name="P:CoAP.Log.LogManager.Level">
            <summary>
            Gets or sets the global log level.
            </summary>
        </member>
        <member name="P:CoAP.Log.LogManager.Instance">
            <summary>
            Gets or sets the <see cref="T:CoAP.Log.ILogManager"/> to provide loggers.
            </summary>
        </member>
        <member name="T:CoAP.Log.LogLevel">
            <summary>
            Log levels.
            </summary>
        </member>
        <member name="F:CoAP.Log.LogLevel.All">
            <summary>
            All logs.
            </summary>
        </member>
        <member name="F:CoAP.Log.LogLevel.Debug">
            <summary>
            Debugs and above.
            </summary>
        </member>
        <member name="F:CoAP.Log.LogLevel.Info">
            <summary>
            Infos and above.
            </summary>
        </member>
        <member name="F:CoAP.Log.LogLevel.Warning">
            <summary>
            Warnings and above.
            </summary>
        </member>
        <member name="F:CoAP.Log.LogLevel.Error">
            <summary>
            Errors and above.
            </summary>
        </member>
        <member name="F:CoAP.Log.LogLevel.Fatal">
            <summary>
            Fatals only.
            </summary>
        </member>
        <member name="F:CoAP.Log.LogLevel.None">
            <summary>
            No logs.
            </summary>
        </member>
        <member name="T:CoAP.EmptyMessage">
            <summary>
            Represents an empty CoAP message. An empty message has either
            the <see cref="T:CoAP.MessageType"/> ACK or RST.
            </summary>
        </member>
        <member name="M:CoAP.EmptyMessage.#ctor(CoAP.MessageType)">
            <summary>
            Instantiates a new empty message.
            </summary>
        </member>
        <member name="M:CoAP.EmptyMessage.NewACK(CoAP.Message)">
            <summary>
            Create a new acknowledgment for the specified message.
            </summary>
            <param name="message">the message to acknowledge</param>
            <returns>the acknowledgment</returns>
        </member>
        <member name="M:CoAP.EmptyMessage.NewRST(CoAP.Message)">
            <summary>
            Create a new reset message for the specified message.
            </summary>
            <param name="message">the message to reject</param>
            <returns>the reset</returns>
        </member>
        <member name="T:CoAP.Deduplication.NoopDeduplicator">
            <summary>
            A dummy implementation that does no deduplication.
            </summary>
        </member>
        <member name="M:CoAP.Deduplication.NoopDeduplicator.Start">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Deduplication.NoopDeduplicator.Stop">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Deduplication.NoopDeduplicator.Clear">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Deduplication.NoopDeduplicator.FindPrevious(CoAP.Net.Exchange.KeyID,CoAP.Net.Exchange)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Deduplication.NoopDeduplicator.Find(CoAP.Net.Exchange.KeyID)">
            <inheritdoc/>
        </member>
        <member name="T:System.Collections.Generic.BitHelper">
            <summary>
            ABOUT:
            Helps with operations that rely on bit marking to indicate whether an item in the 
            collection should be added, removed, visited already, etc. 
            
            BitHelper doesn't allocate the array; you must pass in an array or ints allocated on the 
            stack or heap. ToIntArrayLength() tells you the int array size you must allocate. 
            
            USAGE:
            Suppose you need to represent a bit array of length (i.e. logical bit array length)
            BIT_ARRAY_LENGTH. Then this is the suggested way to instantiate BitHelper:
            ***************************************************************************
            int intArrayLength = BitHelper.ToIntArrayLength(BIT_ARRAY_LENGTH);
            BitHelper bitHelper;
            if (intArrayLength less than stack alloc threshold)
                int* m_arrayPtr = stackalloc int[intArrayLength];
                bitHelper = new BitHelper(m_arrayPtr, intArrayLength);
            else
                int[] m_arrayPtr = new int[intArrayLength];
                bitHelper = new BitHelper(m_arrayPtr, intArrayLength);
            ***************************************************************************
            
            IMPORTANT:
            The second ctor args, length, should be specified as the length of the int array, not
            the logical bit array. Because length is used for bounds checking into the int array,
            it's especially important to get this correct for the stackalloc version. See the code 
            samples above; this is the value gotten from ToIntArrayLength(). 
            
            The length ctor argument is the only exception; for other methods -- MarkBit and 
            IsMarked -- pass in values as indices into the logical bit array, and it will be mapped
            to the position within the array of ints.
            
            FUTURE OPTIMIZATIONS:
            A method such as FindFirstMarked/Unmarked Bit would be useful for callers that operate 
            on a bit array and then need to loop over it. In particular, if it avoided visiting 
            every bit, it would allow good perf improvements when the bit array is sparse.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.BitHelper.#ctor(System.Int32*,System.Int32)">
            <summary>
            Instantiates a BitHelper with a heap alloc'd array of ints
            </summary>
            <param name="bitArray">int array to hold bits</param>
            <param name="length">length of int array</param>
        </member>
        <member name="M:System.Collections.Generic.BitHelper.#ctor(System.Int32[],System.Int32)">
            <summary>
            Instantiates a BitHelper with a heap alloc'd array of ints
            </summary>
            <param name="bitArray">int array to hold bits</param>
            <param name="length">length of int array</param>
        </member>
        <member name="M:System.Collections.Generic.BitHelper.MarkBit(System.Int32)">
            <summary>
            Mark bit at specified position
            </summary>
            <param name="bitPosition"></param>
        </member>
        <member name="M:System.Collections.Generic.BitHelper.IsMarked(System.Int32)">
            <summary>
            Is bit at specified position marked?
            </summary>
            <param name="bitPosition"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.BitHelper.ToIntArrayLength(System.Int32)">
            <summary>
            How many ints must be allocated to represent n bits. Returns (n+31)/32, but 
            avoids overflow
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="T:CoAP.Server.ServerMessageDeliverer">
            <summary>
            Delivers requests to corresponding resources and
            responses to corresponding requests.
            </summary>
        </member>
        <member name="M:CoAP.Server.ServerMessageDeliverer.#ctor(CoAP.ICoapConfig,CoAP.Server.Resources.IResource)">
            <summary>
            Constructs a default message deliverer that delivers requests
            to the resources rooted at the specified root.
            </summary>
        </member>
        <member name="M:CoAP.Server.ServerMessageDeliverer.DeliverRequest(CoAP.Net.Exchange)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Server.ServerMessageDeliverer.DeliverResponse(CoAP.Net.Exchange,CoAP.Response)">
            <inheritdoc/>
        </member>
        <member name="T:CoAP.OptionType">
            <summary>
            CoAP option types as defined in
            RFC 7252, Section 12.2 and other CoAP extensions.
            </summary>
        </member>
        <member name="F:CoAP.OptionType.Reserved">
            <summary>
            <remarks>RFC 7252</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.IfMatch">
            <summary>
            C, opaque, 0-8 B, -
            <remarks>RFC 7252</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.UriHost">
            <summary>
            C, String, 1-270 B, ""
            <remarks>RFC 7252</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.ETag">
            <summary>
            E, sequence of bytes, 1-4 B, -
            <remarks>RFC 7252</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.IfNoneMatch">
            <summary>
            <remarks>RFC 7252</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.UriPort">
            <summary>
            C, uint, 0-2 B
            <remarks>RFC 7252</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.LocationPath">
            <summary>
            E, String, 1-270 B, -
            <remarks>RFC 7252</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.UriPath">
            <summary>
            C, String, 1-270 B, ""
            <remarks>RFC 7252</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.ContentType">
            <summary>
            C, 8-bit uint, 1 B, 0 (text/plain)
            <seealso cref="F:CoAP.OptionType.ContentFormat"/>
            <remarks>RFC 7252</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.ContentFormat">
            <summary>
            C, 8-bit uint, 1 B, 0 (text/plain)
            <remarks>RFC 7252</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.MaxAge">
            <summary>
            E, variable length, 1--4 B, 60 Seconds
            <remarks>RFC 7252</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.UriQuery">
            <summary>
            C, String, 1-270 B, ""
            <remarks>RFC 7252</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.Accept">
            <summary>
            C, Sequence of Bytes, 1-n B, -
            <remarks>RFC 7252</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.Token">
            <summary>
            C, Sequence of Bytes, 1-2 B, -. NOTE: this option has been replaced with <see cref="P:CoAP.Message.Token"/> since draft 13.
            <remarks>draft-ietf-core-coap-03, draft-ietf-core-coap-12</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.LocationQuery">
            <summary>
            E, String, 1-270 B, -
            <remarks>RFC 7252</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.ProxyUri">
            <summary>
            C, String, 1-270 B, "coap"
            <remarks>RFC 7252</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.ProxyScheme">
            <summary>
            <remarks>RFC 7252</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.Size1">
            <summary>
            <remarks>RFC 7252</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.Reserved1">
            <summary>
            <remarks>RFC 7252</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.Reserved2">
            <summary>
            <remarks>RFC 7252</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.Reserved3">
            <summary>
            <remarks>RFC 7252</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.Reserved4">
            <summary>
            <remarks>RFC 7252</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.Observe">
            <summary>
            E, Duration, 1 B, 0
            <remarks>draft-ietf-core-observe</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.Block2">
            <summary>
            <remarks>draft-ietf-core-block</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.Block1">
            <summary>
            <remarks>draft-ietf-core-block</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.Size2">
            <summary>
            <remarks>draft-ietf-core-block</remarks>
            </summary>
        </member>
        <member name="F:CoAP.OptionType.FencepostDivisor">
            <summary>
            no-op for fenceposting
            <remarks>draft-bormann-coap-misc-04</remarks>
            </summary>
        </member>
        <member name="T:CoAP.OptionFormat">
            <summary>
            CoAP option formats
            </summary>
        </member>
        <member name="T:CoAP.Server.Resources.TimerResource">
            <summary>
            Represents a periodic resource based on a timer.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.TimerResource.#ctor(System.String,System.Int32)">
            <summary>
            Instantiates.
            </summary>
            <param name="resourceIdentifier">the name</param>
            <param name="period">the period to notify</param>
        </member>
        <member name="M:CoAP.Server.Resources.TimerResource.Tick(System.Object)">
            <summary>
            Fires a changed event.
            </summary>
            <param name="o"></param>
        </member>
        <member name="T:CoAP.CoapConfig">
            <summary>
            Default implementation of <see cref="T:CoAP.ICoapConfig"/>.
            </summary>
        </member>
        <member name="M:CoAP.CoapConfig.#ctor">
            <summary>
            Instantiate.
            </summary>
        </member>
        <member name="M:CoAP.CoapConfig.Load(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.CoapConfig.Store(System.String)">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.Version">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.DefaultPort">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.DefaultSecurePort">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.HttpPort">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.AckTimeout">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.AckRandomFactor">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.AckTimeoutScale">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.MaxRetransmit">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.MaxMessageSize">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.DefaultBlockSize">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.BlockwiseStatusLifetime">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.UseRandomIDStart">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.UseRandomTokenStart">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.Deduplicator">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.CropRotationPeriod">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.ExchangeLifetime">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.MarkAndSweepInterval">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.NotificationMaxAge">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.NotificationCheckIntervalTime">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.NotificationCheckIntervalCount">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.NotificationReregistrationBackoff">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.ChannelReceiveBufferSize">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.ChannelSendBufferSize">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.ChannelReceivePacketSize">
            <inheritdoc/>
        </member>
        <member name="E:CoAP.CoapConfig.PropertyChanged">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.CoapConfig.Spec">
            <inheritdoc/>
        </member>
        <member name="T:CoAP.Channel.DataReceivedEventArgs">
            <summary>
            Provides data for <see cref="E:CoAP.Channel.IChannel.DataReceived"/> event.
            </summary>
        </member>
        <member name="M:CoAP.Channel.DataReceivedEventArgs.#ctor(System.Byte[],System.Net.EndPoint)">
            <summary>
            </summary>
        </member>
        <member name="P:CoAP.Channel.DataReceivedEventArgs.Data">
            <summary>
            Gets the received bytes.
            </summary>
        </member>
        <member name="P:CoAP.Channel.DataReceivedEventArgs.EndPoint">
            <summary>
            Gets the <see cref="T:System.Net.EndPoint"/> where the data is received from.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentQueue`1">
            <summary>
            Represents a thread-safe first-in, first-out collection of objects.
            </summary>
            <typeparam name="T">Specifies the type of elements in the queue.</typeparam>
            <remarks>
            All public  and protected members of <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> are thread-safe and may be used
            concurrently from multiple threads.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> class.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.InitializeFromCollection(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes the contents of the queue from an existing collection.
            </summary>
            <param name="collection">A collection from which to copy elements.</param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>
            class that contains elements copied from the specified collection
            </summary>
            <param name="collection">The collection whose elements are copied to the new <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="collection"/> argument is
            null.</exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"/> to an <see cref="T:System.Array"/>, starting at a particular
            <see cref="T:System.Array"/> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array">Array</see> that is the
            destination of the elements copied from the
            <see cref="T:System.Collections.Concurrent.ConcurrentBag"/>. The <see cref="T:System.Array">Array</see> must have zero-based indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying
            begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in
            Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            zero.</exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="array"/> is multidimensional. -or-
            <paramref name="array"/> does not have zero-based indexing. -or-
            <paramref name="index"/> is equal to or greater than the length of the <paramref name="array"/>
            -or- The number of elements in the source <see cref="T:System.Collections.ICollection"/> is
            greater than the available space from <paramref name="index"/> to the end of the destination
            <paramref name="array"/>. -or- The type of the source <see cref="T:System.Collections.ICollection"/> cannot be cast automatically to the type of the
            destination <paramref name="array"/>.
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryAdd(`0)">
            <summary>
            Attempts to add an object to the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}"/>.
            </summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}"/>. The value can be a null
            reference (Nothing in Visual Basic) for reference types.
            </param>
            <returns>true if the object was added successfully; otherwise, false.</returns>
            <remarks>For <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>, this operation will always add the object to the
            end of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>
            and return true.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryTake(`0@)">
            <summary>
            Attempts to remove and return an object from the <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection{T}"/>.
            </summary>
            <param name="item">
            When this method returns, if the operation was successful, <paramref name="item"/> contains the
            object removed. If no object was available to be removed, the value is unspecified.
            </param>
            <returns>true if an element was removed and returned successfully; otherwise, false.</returns>
            <remarks>For <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>, this operation will attempt to remove the object
            from the beginning of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.ToArray">
            <summary>
            Copies the elements stored in the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> to a new array.
            </summary>
            <returns>A new array containing a snapshot of elements copied from the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.ToList">
            <summary>
            Copies the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> elements to a new <see cref="T:System.Collections.Generic.List{T}"/>.
            </summary>
            <returns>A new <see cref="T:System.Collections.Generic.List{T}"/> containing a snapshot of
            elements copied from the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.GetHeadTailPositions(System.Collections.Concurrent.ConcurrentQueue{`0}.Segment@,System.Collections.Concurrent.ConcurrentQueue{`0}.Segment@,System.Int32@,System.Int32@)">
            <summary>
            Store the position of the current head and tail positions.
            </summary>
            <param name="head">return the head segment</param>
            <param name="tail">return the tail segment</param>
            <param name="headLow">return the head offset, value range [0, SEGMENT_SIZE]</param>
            <param name="tailHigh">return the tail offset, value range [-1, SEGMENT_SIZE-1]</param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> elements to an existing one-dimensional <see cref="T:System.Array">Array</see>, starting at the specified array index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array">Array</see> that is the
            destination of the elements copied from the
            <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>. The <see cref="T:System.Array">Array</see> must have zero-based
            indexing.</param>
            <param name="index">The zero-based index in <paramref name="array"/> at which copying
            begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is a null reference (Nothing in
            Visual Basic).</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is less than
            zero.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="index"/> is equal to or greater than the
            length of the <paramref name="array"/>
            -or- The number of elements in the source <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> is greater than the
            available space from <paramref name="index"/> to the end of the destination <paramref name="array"/>.
            </exception>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.
            </summary>
            <returns>An enumerator for the contents of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.</returns>
            <remarks>
            The enumeration represents a moment-in-time snapshot of the contents
            of the queue.  It does not reflect any updates to the collection after 
            <see cref="M:System.Collections.Concurrent.ConcurrentQueue`1.GetEnumerator"/> was called.  The enumerator is safe to use
            concurrently with reads from and writes to the queue.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.GetEnumerator(System.Collections.Concurrent.ConcurrentQueue{`0}.Segment,System.Collections.Concurrent.ConcurrentQueue{`0}.Segment,System.Int32,System.Int32)">
            <summary>
            Helper method of GetEnumerator to separate out yield return statement, and prevent lazy evaluation. 
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Enqueue(`0)">
            <summary>
            Adds an object to the end of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.
            </summary>
            <param name="item">The object to add to the end of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>. The value can be a null reference
            (Nothing in Visual Basic) for reference types.
            </param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.TryDequeue(`0@)">
            <summary>
            Attempts to remove and return the object at the beginning of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.
            </summary>
            <param name="result">
            When this method returns, if the operation was successful, <paramref name="result"/> contains the
            object removed. If no object was available to be removed, the value is unspecified.
            </param>
            <returns>true if an element was removed and returned from the beginning of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>
            successfully; otherwise, false.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.TryPeek(`0@)">
            <summary>
            Attempts to return an object from the beginning of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>
            without removing it.
            </summary>
            <param name="result">When this method returns, <paramref name="result"/> contains an object from
            the beginning of the <see cref="T:System.Collections.Concurrent.ConcurrentQueue{T}"/> or an
            unspecified value if the operation failed.</param>
            <returns>true if and object was returned successfully; otherwise, false.</returns>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"/> is
            synchronized with the SyncRoot.
            </summary>
            <value>true if access to the <see cref="T:System.Collections.ICollection"/> is synchronized
            with the SyncRoot; otherwise, false. For <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>, this property always
            returns false.</value>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see
            cref="T:System.Collections.ICollection"/>. This property is not supported.
            </summary>
            <exception cref="T:System.NotSupportedException">The SyncRoot property is not supported.</exception>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.IsEmpty">
            <summary>
            Gets a value that indicates whether the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> is empty.
            </summary>
            <value>true if the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> is empty; otherwise, false.</value>
            <remarks>
            For determining whether the collection contains any items, use of this property is recommended
            rather than retrieving the number of items from the <see cref="P:System.Collections.Concurrent.ConcurrentQueue`1.Count"/> property and comparing it
            to 0.  However, as this collection is intended to be accessed concurrently, it may be the case
            that another thread will modify the collection after <see cref="P:System.Collections.Concurrent.ConcurrentQueue`1.IsEmpty"/> returns, thus invalidating
            the result.
            </remarks>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.
            </summary>
            <value>The number of elements contained in the <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/>.</value>
            <remarks>
            For determining whether the collection contains any items, use of the <see cref="P:System.Collections.Concurrent.ConcurrentQueue`1.IsEmpty"/>
            property is recommended rather than retrieving the number of items from the <see cref="P:System.Collections.Concurrent.ConcurrentQueue`1.Count"/>
            property and comparing it to 0.
            </remarks>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentQueue`1.Segment">
            <summary>
            private class for ConcurrentQueue. 
            a queue is a linked list of small arrays, each node is called a segment.
            A segment contains an array, a pointer to the next segment, and _low, _high indices recording
            the first and last valid elements of the array.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Segment.#ctor(System.Int64,System.Collections.Concurrent.ConcurrentQueue{`0})">
            <summary>
            Create and initialize a segment with the specified index.
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Segment.UnsafeAdd(`0)">
            <summary>
            Add an element to the tail of the current segment
            exclusively called by ConcurrentQueue.InitializedFromCollection
            InitializeFromCollection is responsible to guarantee that there is no index overflow,
            and there is no contention
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Segment.UnsafeGrow">
            <summary>
            Create a new segment and append to the current one
            Does not update the _tail pointer
            exclusively called by ConcurrentQueue.InitializedFromCollection
            InitializeFromCollection is responsible to guarantee that there is no index overflow,
            and there is no contention
            </summary>
            <returns>the reference to the new Segment</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Segment.Grow">
            <summary>
            Create a new segment and append to the current one
            Update the _tail pointer
            This method is called when there is no contention
            </summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Segment.TryAppend(`0)">
            <summary>
            Try to append an element at the end of this segment.
            </summary>
            <param name="value">the element to append</param>
            <param name="tail">The tail.</param>
            <returns>true if the element is appended, false if the current segment is full</returns>
            <remarks>if appending the specified element succeeds, and after which the segment is full, 
            then grow the segment</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Segment.TryRemove(`0@)">
            <summary>
            try to remove an element from the head of current segment
            </summary>
            <param name="result">The result.</param>
            <param name="head">The head.</param>
            <returns>return false only if the current segment is empty</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Segment.TryPeek(`0@)">
            <summary>
            try to peek the current segment
            </summary>
            <param name="result">holds the return value of the element at the head position, 
            value set to default(T) if there is no such an element</param>
            <returns>true if there are elements in the current segment, false otherwise</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentQueue`1.Segment.AddToList(System.Collections.Generic.List{`0},System.Int32,System.Int32)">
            <summary>
            Adds part or all of the current segment into a List.
            </summary>
            <param name="list">the list to which to add</param>
            <param name="start">the start position</param>
            <param name="end">the end position</param>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.Segment.Next">
            <summary>
            return the next segment
            </summary>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.Segment.IsEmpty">
            <summary>
            return true if the current segment is empty (doesn't have any element available to dequeue, 
            false otherwise
            </summary>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.Segment.Low">
            <summary>
            return the position of the head of the current segment
            Value range [0, SEGMENT_SIZE], if it's SEGMENT_SIZE, it means this segment is exhausted and thus empty
            </summary>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentQueue`1.Segment.High">
            <summary>
            return the logical position of the tail of the current segment      
            Value range [-1, SEGMENT_SIZE-1]. When it's -1, it means this is a new segment and has no elemnet yet
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.VolatileBool">
            <summary>
            A wrapper struct for volatile bool, please note the copy of the struct it self will not be volatile
            for example this statement will not include in volatile operation volatileBool1 = volatileBool2 the jit will copy the struct and will ignore the volatile
            </summary>
        </member>
        <member name="T:CoAP.Threading.ThreadPoolExecutor">
            <summary>
            <see cref="T:CoAP.Threading.IExecutor"/> that use the <see cref="T:System.Threading.ThreadPool"/>.
            </summary>
        </member>
        <member name="M:CoAP.Threading.ThreadPoolExecutor.Start(CoAP.Action)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Threading.ThreadPoolExecutor.Start(System.Action{System.Object},System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:CoAP.Stack.BlockwiseStatus">
            <summary>
            Represents the status of a blockwise transfer of a request or a response.
            </summary>
        </member>
        <member name="M:CoAP.Stack.BlockwiseStatus.#ctor(System.Int32)">
            <summary>
            Instantiates a new blockwise status.
            </summary>
        </member>
        <member name="M:CoAP.Stack.BlockwiseStatus.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Instantiates a new blockwise status.
            </summary>
        </member>
        <member name="M:CoAP.Stack.BlockwiseStatus.AddBlock(System.Byte[])">
            <summary>
            Adds the specified block to the current list of blocks.
            </summary>
        </member>
        <member name="M:CoAP.Stack.BlockwiseStatus.ToString">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Stack.BlockwiseStatus.CurrentNUM">
            <summary>
            Gets or sets the current num.
            </summary>
        </member>
        <member name="P:CoAP.Stack.BlockwiseStatus.CurrentSZX">
            <summary>
            Gets or sets the current szx.
            </summary>
        </member>
        <member name="P:CoAP.Stack.BlockwiseStatus.IsRandomAccess">
            <summary>
            Gets or sets if this status is for random access.
            </summary>
        </member>
        <member name="P:CoAP.Stack.BlockwiseStatus.ContentFormat">
            <summary>
            Gets the initial Content-Format, which must stay the same for the whole transfer.
            </summary>
        </member>
        <member name="P:CoAP.Stack.BlockwiseStatus.Complete">
            <summary>
            Gets or sets a value indicating if this is complete.
            </summary>
        </member>
        <member name="P:CoAP.Stack.BlockwiseStatus.BlockCount">
            <summary>
            Gets the number of blocks.
            </summary>
        </member>
        <member name="P:CoAP.Stack.BlockwiseStatus.Blocks">
            <summary>
            Gets all blocks.
            </summary>
        </member>
        <member name="M:CoAP.Stack.BlockwiseLayer.#ctor(CoAP.ICoapConfig)">
            <summary>
            Constructs a new blockwise layer.
            </summary>
        </member>
        <member name="M:CoAP.Stack.BlockwiseLayer.SendRequest(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.Request)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.BlockwiseLayer.ReceiveRequest(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.Request)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.BlockwiseLayer.SendResponse(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.Response)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.BlockwiseLayer.ReceiveResponse(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.Response)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.BlockwiseLayer.FindRequestBlockStatus(CoAP.Net.Exchange,CoAP.Request)">
            <summary>
            Notice:
            This method is used by SendRequest and ReceiveRequest.
            Be careful, making changes to the status in here.
            </summary>
        </member>
        <member name="M:CoAP.Stack.BlockwiseLayer.FindResponseBlockStatus(CoAP.Net.Exchange,CoAP.Response)">
            <summary>
            Notice:
            This method is used by SendResponse and ReceiveResponse.
            Be careful, making changes to the status in here.
            </summary>
        </member>
        <member name="M:CoAP.Stack.BlockwiseLayer.PrepareBlockCleanup(CoAP.Net.Exchange)">
            <summary>
            Schedules a clean-up task.
            Use the <see cref="P:CoAP.ICoapConfig.BlockwiseStatusLifetime"/> to set the timeout.
            </summary>
        </member>
        <member name="M:CoAP.Stack.BlockwiseLayer.ClearBlockCleanup(CoAP.Net.Exchange)">
            <summary>
            Clears the clean-up task.
            </summary>
        </member>
        <member name="T:CoAP.Observe.ObservingEndpoint">
            <summary>
            Represents an observing endpoint. It holds all observe relations
            that the endpoint has to this server. If a confirmable notification timeouts
            for the maximum times allowed the server assumes the client is no longer
            reachable and cancels all relations that it has established to resources.
            </summary>
        </member>
        <member name="M:CoAP.Observe.ObservingEndpoint.#ctor(System.Net.EndPoint)">
            <summary>
            Constructs a new observing endpoint.
            </summary>
        </member>
        <member name="M:CoAP.Observe.ObservingEndpoint.AddObserveRelation(CoAP.Observe.ObserveRelation)">
            <summary>
            Adds the specified observe relation.
            </summary>
        </member>
        <member name="M:CoAP.Observe.ObservingEndpoint.RemoveObserveRelation(CoAP.Observe.ObserveRelation)">
            <summary>
            Removes the specified observe relation.
            </summary>
        </member>
        <member name="M:CoAP.Observe.ObservingEndpoint.GetObserveRelation(System.Byte[])">
            <summary>
            Finds the observe relation by token.
            </summary>
        </member>
        <member name="M:CoAP.Observe.ObservingEndpoint.CancelAll">
            <summary>
            Cancels all observe relations that this endpoint has established with
            resources from this server.
            </summary>
        </member>
        <member name="P:CoAP.Observe.ObservingEndpoint.EndPoint">
            <summary>
            Gets the <see cref="T:System.Net.EndPoint"/> of this endpoint.
            </summary>
        </member>
        <member name="T:CoAP.MediaType">
            <summary>
            This class describes the CoAP Media Type Registry as defined in
            RFC 7252, Section 12.3.
            </summary>
        </member>
        <member name="F:CoAP.MediaType.Undefined">
            <summary>
            undefined
            </summary>
        </member>
        <member name="F:CoAP.MediaType.TextPlain">
            <summary>
            text/plain; charset=utf-8
            </summary>
        </member>
        <member name="F:CoAP.MediaType.TextXml">
            <summary>
            text/xml
            </summary>
        </member>
        <member name="F:CoAP.MediaType.TextCsv">
            <summary>
            text/csv
            </summary>
        </member>
        <member name="F:CoAP.MediaType.TextHtml">
            <summary>
            text/html
            </summary>
        </member>
        <member name="F:CoAP.MediaType.ImageGif">
            <summary>
            image/gif
            </summary>
        </member>
        <member name="F:CoAP.MediaType.ImageJpeg">
            <summary>
            image/jpeg
            </summary>
        </member>
        <member name="F:CoAP.MediaType.ImagePng">
            <summary>
            image/png
            </summary>
        </member>
        <member name="F:CoAP.MediaType.ImageTiff">
            <summary>
            image/tiff
            </summary>
        </member>
        <member name="F:CoAP.MediaType.AudioRaw">
            <summary>
            audio/raw
            </summary>
        </member>
        <member name="F:CoAP.MediaType.VideoRaw">
            <summary>
            video/raw
            </summary>
        </member>
        <member name="F:CoAP.MediaType.ApplicationLinkFormat">
            <summary>
            application/link-format
            </summary>
        </member>
        <member name="F:CoAP.MediaType.ApplicationXml">
            <summary>
            application/xml
            </summary>
        </member>
        <member name="F:CoAP.MediaType.ApplicationOctetStream">
            <summary>
            application/octet-stream
            </summary>
        </member>
        <member name="F:CoAP.MediaType.ApplicationRdfXml">
            <summary>
            application/rdf+xml
            </summary>
        </member>
        <member name="F:CoAP.MediaType.ApplicationSoapXml">
            <summary>
            application/soap+xml
            </summary>
        </member>
        <member name="F:CoAP.MediaType.ApplicationAtomXml">
            <summary>
            application/atom+xml
            </summary>
        </member>
        <member name="F:CoAP.MediaType.ApplicationXmppXml">
            <summary>
            application/xmpp+xml
            </summary>
        </member>
        <member name="F:CoAP.MediaType.ApplicationExi">
            <summary>
            application/exi
            </summary>
        </member>
        <member name="F:CoAP.MediaType.ApplicationFastinfoset">
            <summary>
            application/fastinfoset
            </summary>
        </member>
        <member name="F:CoAP.MediaType.ApplicationSoapFastinfoset">
            <summary>
            application/soap+fastinfoset
            </summary>
        </member>
        <member name="F:CoAP.MediaType.ApplicationJson">
            <summary>
            application/json
            </summary>
        </member>
        <member name="F:CoAP.MediaType.ApplicationXObixBinary">
            <summary>
            application/x-obix-binary
            </summary>
        </member>
        <member name="F:CoAP.MediaType.Any">
            <summary>
            any
            </summary>
        </member>
        <member name="M:CoAP.MediaType.IsImage(System.Int32)">
            <summary>
            Checks whether the given media type is a type of image.
            </summary>
            <param name="mediaType">The media type to be checked</param>
            <returns>True iff the media type is a type of image</returns>
        </member>
        <member name="M:CoAP.MediaType.ToString(System.Int32)">
            <summary>
            Returns a string representation of the media type.
            </summary>
            <param name="mediaType">The media type to be described</param>
            <returns>A string describing the media type</returns>
        </member>
        <member name="M:CoAP.MediaType.ToFileExtension(System.Int32)">
            <summary>
            Gets the file extension of the given media type.
            </summary>
        </member>
        <member name="T:CoAP.LinkAttribute">
            <summary>
            Class for linkformat attributes.
            </summary>
        </member>
        <member name="M:CoAP.LinkAttribute.#ctor(System.String,System.Object)">
            <summary>
            Initializes an attribute.
            </summary>
        </member>
        <member name="M:CoAP.LinkAttribute.Serialize(System.Text.StringBuilder)">
            <summary>
            Serializes this attribute into its string representation.
            </summary>
            <param name="builder"></param>
        </member>
        <member name="M:CoAP.LinkAttribute.ToString">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.LinkAttribute.CompareTo(CoAP.LinkAttribute)">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.LinkAttribute.Name">
            <summary>
            Gets the name of this attribute.
            </summary>
        </member>
        <member name="P:CoAP.LinkAttribute.Value">
            <summary>
            Gets the value of this attribute.
            </summary>
        </member>
        <member name="P:CoAP.LinkAttribute.IntValue">
            <summary>
            Gets the int value of this attribute.
            </summary>
        </member>
        <member name="P:CoAP.LinkAttribute.StringValue">
            <summary>
            Gets the string value of this attribute.
            </summary>
        </member>
        <member name="T:CoAP.Codec.IMessageDecoder">
            <summary>
            Provides methods to parse incoming byte arrays to messages.
            </summary>
        </member>
        <member name="M:CoAP.Codec.IMessageDecoder.DecodeRequest">
            <summary>
            Decodes as a <see cref="T:CoAP.Request"/>.
            </summary>
            <returns>the decoded request</returns>
        </member>
        <member name="M:CoAP.Codec.IMessageDecoder.DecodeResponse">
            <summary>
            Decodes as a <see cref="T:CoAP.Response"/>.
            </summary>
            <returns>the decoded response</returns>
        </member>
        <member name="M:CoAP.Codec.IMessageDecoder.DecodeEmptyMessage">
            <summary>
            Decodes as a <see cref="T:CoAP.EmptyMessage"/>.
            </summary>
            <returns>the decoded empty message</returns>
        </member>
        <member name="M:CoAP.Codec.IMessageDecoder.Decode">
            <summary>
            Decodes as a CoAP message.
            </summary>
            <returns>the decoded message, or null if not be recognized.</returns>
        </member>
        <member name="P:CoAP.Codec.IMessageDecoder.IsWellFormed">
            <summary>
            Checks if the decoding message is wellformed.
            </summary>
        </member>
        <member name="P:CoAP.Codec.IMessageDecoder.IsReply">
            <summary>
            Checks if the decoding message is a reply.
            </summary>
        </member>
        <member name="P:CoAP.Codec.IMessageDecoder.IsRequest">
            <summary>
            Checks if the decoding message is a request.
            </summary>
        </member>
        <member name="P:CoAP.Codec.IMessageDecoder.IsResponse">
            <summary>
            Checks if the decoding message is a response.
            </summary>
        </member>
        <member name="P:CoAP.Codec.IMessageDecoder.IsEmpty">
            <summary>
            Checks if the decoding message is an empty message.
            </summary>
        </member>
        <member name="P:CoAP.Codec.IMessageDecoder.Version">
            <summary>
            Gets the version of the decoding message.
            </summary>
        </member>
        <member name="P:CoAP.Codec.IMessageDecoder.ID">
            <summary>
            Gets the id of the decoding message.
            </summary>
        </member>
        <member name="T:CoAP.BlockOption">
            <summary>
            This class describes the block options of the CoAP messages
            </summary>
        </member>
        <member name="M:CoAP.BlockOption.#ctor(CoAP.OptionType)">
            <summary>
            Initializes a block option.
            </summary>
            <param name="type">The type of the option</param>
        </member>
        <member name="M:CoAP.BlockOption.#ctor(CoAP.OptionType,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Initializes a block option.
            </summary>
            <param name="type">The type of the option</param>
            <param name="num">Block number</param>
            <param name="szx">Block size</param>
            <param name="m">More flag</param>
        </member>
        <member name="M:CoAP.BlockOption.SetValue(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets block params.
            </summary>
            <param name="num">Block number</param>
            <param name="szx">Block size</param>
            <param name="m">More flag</param>
        </member>
        <member name="M:CoAP.BlockOption.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:CoAP.BlockOption.DecodeSZX(System.Int32)">
            <summary>
            Gets the real block size which is 2 ^ (SZX + 4).
            </summary>
            <param name="szx"></param>
            <returns></returns>
        </member>
        <member name="M:CoAP.BlockOption.EncodeSZX(System.Int32)">
            <summary>
            Converts a block size into the corresponding SZX.
            </summary>
            <param name="blockSize"></param>
            <returns></returns>
        </member>
        <member name="M:CoAP.BlockOption.ValidSZX(System.Int32)">
            <summary>
            Checks whether the given SZX is valid or not.
            </summary>
            <param name="szx"></param>
            <returns></returns>
        </member>
        <member name="P:CoAP.BlockOption.NUM">
            <summary>
            Gets or sets the block number.
            </summary>
        </member>
        <member name="P:CoAP.BlockOption.SZX">
            <summary>
            Gets or sets the block size.
            </summary>
        </member>
        <member name="P:CoAP.BlockOption.M">
            <summary>
            Gets or sets the more flag.
            </summary>
        </member>
        <member name="P:CoAP.BlockOption.Size">
            <summary>
            Gets the decoded block size in bytes (B).
            </summary>
        </member>
        <member name="T:CoAP.MessageEventArgs`1">
            <summary>
            Represents an event of a message.
            </summary>
            <typeparam name="T">the type of the message</typeparam>
        </member>
        <member name="M:CoAP.MessageEventArgs`1.#ctor(`0)">
            <summary>
            
            </summary>
        </member>
        <member name="P:CoAP.MessageEventArgs`1.Message">
            <summary>
            Gets the message.
            </summary>
        </member>
        <member name="T:CoAP.ResponseEventArgs">
            <summary>
            Represents an event when a response arrives for a request.
            </summary>
        </member>
        <member name="M:CoAP.ResponseEventArgs.#ctor(CoAP.Response)">
            <summary>
            
            </summary>
        </member>
        <member name="P:CoAP.ResponseEventArgs.Response">
            <summary>
            Gets the incoming response.
            </summary>
        </member>
        <member name="T:System.Threading.SpinWait">
            <summary>
            Provides support for spin-based waiting.
            </summary>
            <remarks>
            <para>
            <see cref="T:System.Threading.SpinWait"/> encapsulates common spinning logic. On single-processor machines, yields are
            always used instead of busy waits, and on computers with Intel?processors employing Hyper-Threading?    /// technology, it helps to prevent hardware thread starvation. SpinWait encapsulates a good mixture of
            spinning and true yielding.
            </para>
            <para>
            <see cref="T:System.Threading.SpinWait"/> is a value type, which means that low-level code can utilize SpinWait without
            fear of unnecessary allocation overheads. SpinWait is not generally useful for ordinary applications.
            In most cases, you should use the synchronization classes provided by the .NET Framework, such as
            <see cref="T:System.Threading.Monitor"/>. For most purposes where spin waiting is required, however,
            the <see cref="T:System.Threading.SpinWait"/> type should be preferred over the <see cref="M:System.Threading.Thread.SpinWait(System.Int32)"/> method.
            </para>
            <para>
            While SpinWait is designed to be used in concurrent applications, it is not designed to be
            used from multiple threads concurrently.  SpinWait's members are not thread-safe.  If multiple
            threads must spin, each should use its own instance of SpinWait.
            </para>
            </remarks>
        </member>
        <member name="M:System.Threading.SpinWait.SpinOnce">
            <summary>
            Performs a single spin.
            </summary>
            <remarks>
            This is typically called in a loop, and may change in behavior based on the number of times a
            <see cref="M:System.Threading.SpinWait.SpinOnce"/> has been called thus far on this instance.
            </remarks>
        </member>
        <member name="M:System.Threading.SpinWait.Reset">
            <summary>
            Resets the spin counter.
            </summary>
            <remarks>
            This makes <see cref="M:System.Threading.SpinWait.SpinOnce"/> and <see cref="P:System.Threading.SpinWait.NextSpinWillYield"/> behave as though no calls
            to <see cref="M:System.Threading.SpinWait.SpinOnce"/> had been issued on this instance. If a <see cref="T:System.Threading.SpinWait"/> instance
            is reused many times, it may be useful to reset it to avoid yielding too soon.
            </remarks>
        </member>
        <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean})">
            <summary>
            Spins until the specified condition is satisfied.
            </summary>
            <param name="condition">A delegate to be executed over and over until it returns true.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="condition"/> argument is null.</exception>
        </member>
        <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.TimeSpan)">
            <summary>
            Spins until the specified condition is satisfied or until the specified timeout is expired.
            </summary>
            <param name="condition">A delegate to be executed over and over until it returns true.</param>
            <param name="timeout">
            A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, 
            or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <returns>True if the condition is satisfied within the timeout; otherwise, false</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="condition"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative number
            other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue"/>.</exception>
        </member>
        <member name="M:System.Threading.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int32)">
            <summary>
            Spins until the specified condition is satisfied or until the specified timeout is expired.
            </summary>
            <param name="condition">A delegate to be executed over and over until it returns true.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <returns>True if the condition is satisfied within the timeout; otherwise, false</returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="condition"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
        </member>
        <member name="P:System.Threading.SpinWait.Count">
            <summary>
            Gets the number of times <see cref="M:System.Threading.SpinWait.SpinOnce"/> has been called on this instance.
            </summary>
        </member>
        <member name="P:System.Threading.SpinWait.NextSpinWillYield">
            <summary>
            Gets whether the next call to <see cref="M:System.Threading.SpinWait.SpinOnce"/> will yield the processor, triggering a
            forced context switch.
            </summary>
            <value>Whether the next call to <see cref="M:System.Threading.SpinWait.SpinOnce"/> will yield the processor, triggering a
            forced context switch.</value>
            <remarks>
            On a single-CPU machine, <see cref="M:System.Threading.SpinWait.SpinOnce"/> always yields the processor. On machines with
            multiple CPUs, <see cref="M:System.Threading.SpinWait.SpinOnce"/> may yield after an unspecified number of calls.
            </remarks>
        </member>
        <member name="T:System.Threading.PlatformHelper">
            <summary>
            A helper class to get the number of processors, it updates the numbers of processors every sampling interval.
            </summary>
        </member>
        <member name="P:System.Threading.PlatformHelper.ProcessorCount">
            <summary>
            Gets the number of available processors
            </summary>
        </member>
        <member name="P:System.Threading.PlatformHelper.IsSingleProcessor">
            <summary>
            Gets whether the current machine has only a single processor.
            </summary>
        </member>
        <member name="T:System.Threading.TimeoutHelper">
            <summary>
            A helper class to capture a start time using Environment.TickCout as a time in milliseconds, also updates a given timeout bu subtracting the current time from
            the start time
            </summary>
        </member>
        <member name="M:System.Threading.TimeoutHelper.GetTime">
            <summary>
            Returns the Environment.TickCount as a start time in milliseconds as a uint, TickCount tools over from postive to negative every ~ 25 days
            then ~25 days to back to positive again, uint is sued to ignore the sign and double the range to 50 days
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Threading.TimeoutHelper.UpdateTimeOut(System.UInt32,System.Int32)">
            <summary>
            Helper function to measure and update the elapsed time
            </summary>
            <param name="startTime"> The first time (in milliseconds) observed when the wait started</param>
            <param name="originalWaitMillisecondsTimeout">The orginal wait timeoutout in milliseconds</param>
            <returns>The new wait time in milliseconds, -1 if the time expired</returns>
        </member>
        <member name="F:CoAP.Stack.ObserveLayer._backoff">
            <summary>
            Additional time to wait until re-registration
            </summary>
        </member>
        <member name="M:CoAP.Stack.ObserveLayer.#ctor(CoAP.ICoapConfig)">
            <summary>
            Constructs a new observe layer.
            </summary>
        </member>
        <member name="M:CoAP.Stack.ObserveLayer.SendResponse(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.Response)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.ObserveLayer.ReceiveResponse(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.Response)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Stack.ObserveLayer.ReceiveEmptyMessage(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.EmptyMessage)">
            <inheritdoc/>
        </member>
        <member name="F:CoAP.Spec.Draft03">
            <summary>
            draft-ietf-core-coap-03
            </summary>
        </member>
        <member name="F:CoAP.Spec.Draft08">
            <summary>
            draft-ietf-core-coap-08
            </summary>
        </member>
        <member name="F:CoAP.Spec.Draft12">
            <summary>
            draft-ietf-core-coap-12
            </summary>
        </member>
        <member name="F:CoAP.Spec.Draft13">
            <summary>
            draft-ietf-core-coap-13
            </summary>
        </member>
        <member name="F:CoAP.Spec.Draft18">
            <summary>
            draft-ietf-core-coap-18
            </summary>
        </member>
        <member name="F:CoAP.Spec.RFC7252">
            <summary>
            RFC 7252
            </summary>
        </member>
        <member name="F:CoAP.Spec.Default">
            <summary>
            The default draft.
            </summary>
        </member>
        <member name="T:CoAP.ISpec">
            <summary>
            Represents a draft version of CoAP specification.
            </summary>
        </member>
        <member name="M:CoAP.ISpec.Encode(CoAP.Message)">
            <summary>
            Encodes a CoAP message into a bytes array.
            </summary>
            <param name="msg">the message to encode</param>
            <returns>
            the encoded bytes, or null if the message can not be encoded,
            i.e. the message is not a <see cref="T:CoAP.Request"/>, a <see cref="T:CoAP.Response"/> or an <see cref="T:CoAP.EmptyMessage"/>.
            </returns>
        </member>
        <member name="M:CoAP.ISpec.Decode(System.Byte[])">
            <summary>
            Decodes a CoAP message from a bytes array.
            </summary>
            <param name="bytes">the encoded bytes</param>
            <returns>the decoded message, or null if the bytes array can not be recognized.</returns>
        </member>
        <member name="M:CoAP.ISpec.NewMessageEncoder">
            <summary>
            Gets a <see cref="T:CoAP.Codec.IMessageEncoder"/>.
            </summary>
        </member>
        <member name="M:CoAP.ISpec.NewMessageDecoder(System.Byte[])">
            <summary>
            Gets a <see cref="T:CoAP.Codec.IMessageDecoder"/>.
            </summary>
        </member>
        <member name="P:CoAP.ISpec.Name">
            <summary>
            Gets the name of this draft.
            </summary>
        </member>
        <member name="P:CoAP.ISpec.DefaultPort">
            <summary>
            Gets the default CoAP port in this draft.
            </summary>
        </member>
        <member name="T:CoAP.Codec.MessageDecoder">
            <summary>
            Base class for message decoders.
            </summary>
        </member>
        <member name="F:CoAP.Codec.MessageDecoder.m_reader">
            <summary>
            the bytes reader
            </summary>
        </member>
        <member name="F:CoAP.Codec.MessageDecoder.m_version">
            <summary>
            the version of the decoding message
            </summary>
        </member>
        <member name="F:CoAP.Codec.MessageDecoder.m_type">
            <summary>
            the type of the decoding message
            </summary>
        </member>
        <member name="F:CoAP.Codec.MessageDecoder.m_tokenLength">
            <summary>
            the length of token
            </summary>
        </member>
        <member name="F:CoAP.Codec.MessageDecoder.m_code">
            <summary>
            the code of the decoding message
            </summary>
        </member>
        <member name="F:CoAP.Codec.MessageDecoder.m_id">
            <summary>
            the id of the decoding message
            </summary>
        </member>
        <member name="M:CoAP.Codec.MessageDecoder.#ctor(System.Byte[])">
            <summary>
            Instantiates.
            </summary>
            <param name="data">the bytes array to decode</param>
        </member>
        <member name="M:CoAP.Codec.MessageDecoder.ReadProtocol">
            <summary>
            Reads protocol headers.
            </summary>
        </member>
        <member name="M:CoAP.Codec.MessageDecoder.DecodeRequest">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Codec.MessageDecoder.DecodeResponse">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Codec.MessageDecoder.DecodeEmptyMessage">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Codec.MessageDecoder.Decode">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Codec.MessageDecoder.ParseMessage(CoAP.Message)">
            <summary>
            Parses the rest data other than protocol headers into the given message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="P:CoAP.Codec.MessageDecoder.IsWellFormed">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Codec.MessageDecoder.IsReply">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Codec.MessageDecoder.IsRequest">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Codec.MessageDecoder.IsResponse">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Codec.MessageDecoder.IsEmpty">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Codec.MessageDecoder.Version">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Codec.MessageDecoder.ID">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Draft08.IsFencepost(System.Int32)">
            <summary>
            Checks whether an option is a fencepost option.
            </summary>
            <param name="type">The option type to check</param>
            <returns>True iff the option is a fencepost option</returns>
        </member>
        <member name="M:CoAP.Draft08.NextFencepost(System.Int32)">
            <summary>
            Returns the next fencepost option number following a given option number.
            </summary>
            <param name="optionNumber">The option number</param>
            <returns>The smallest fencepost option number larger than the given option</returns>
        </member>
        <member name="M:CoAP.Draft13.GetValueFromOptionNibble(System.Int32,CoAP.Codec.DatagramReader)">
            <summary>
            Calculates the value used in the extended option fields as specified
            in draft-ietf-core-coap-13, section 3.1.
            </summary>
            <param name="nibble">the 4-bit option header value</param>
            <param name="datagram">the datagram</param>
            <returns>the value calculated from the nibble and the extended option value</returns>
        </member>
        <member name="M:CoAP.Draft13.GetOptionNibble(System.Int32)">
            <summary>
            Returns the 4-bit option header value.
            </summary>
            <param name="optionValue">the option value (delta or length) to be encoded</param>
            <returns>the 4-bit option header value</returns>
        </member>
        <member name="M:CoAP.Draft18.GetOptionNibble(System.Int32)">
            <summary>
            Returns the 4-bit option header value.
            </summary>
            <param name="optionValue">the option value (delta or length) to be encoded</param>
            <returns>the 4-bit option header value</returns>
        </member>
        <member name="M:CoAP.Draft18.GetValueFromOptionNibble(System.Int32,CoAP.Codec.DatagramReader)">
            <summary>
            Calculates the value used in the extended option fields as specified
            in draft-ietf-core-coap-14, section 3.1.
            </summary>
            <param name="nibble">the 4-bit option header value</param>
            <param name="datagram">the datagram</param>
            <returns>the value calculated from the nibble and the extended option value</returns>
        </member>
        <member name="T:CoAP.Server.Resources.DiscoveryResource">
            <summary>
            Represents the CoAP .well-known/core resource.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.DiscoveryResource.#ctor(CoAP.Server.Resources.IResource)">
            <summary>
            Instantiates a new discovery resource.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.DiscoveryResource.#ctor(System.String,CoAP.Server.Resources.IResource)">
            <summary>
            Instantiates a new discovery resource with the specified name.
            </summary>
        </member>
        <member name="M:CoAP.Server.Resources.DiscoveryResource.DoGet(CoAP.Server.Resources.CoapExchange)">
            <inheritdoc/>
        </member>
        <member name="T:CoAP.Net.Exchange">
            <summary>
            Represents the complete state of an exchange of one request
            and one or more responses. The lifecycle of an exchange ends
            when either the last response has arrived and is acknowledged,
            when a request or response has been rejected from the remote endpoint,
            when the request has been canceled, or when a request or response timed out,
            i.e., has reached the retransmission limit without being acknowledged.
            </summary>
        </member>
        <member name="M:CoAP.Net.Exchange.SendReject">
            <summary>
            Reject this exchange and therefore the request.
            Sends an RST back to the client.
            </summary>
        </member>
        <member name="M:CoAP.Net.Exchange.SendAccept">
            <summary>
            Accept this exchange and therefore the request. Only if the request's
            type was a <code>CON</code> and the request has not been acknowledged
            yet, it sends an ACK to the client.
            </summary>
        </member>
        <member name="M:CoAP.Net.Exchange.SendResponse(CoAP.Response)">
            <summary>
            Sends the specified response over the same endpoint
            as the request has arrived.
            </summary>
        </member>
        <member name="P:CoAP.Net.Exchange.EndPoint">
            <summary>
            Gets or sets the endpoint which has created and processed this exchange.
            </summary>
        </member>
        <member name="P:CoAP.Net.Exchange.RequestBlockStatus">
            <summary>
            Gets or sets the status of the blockwise transfer of the request,
            or null in case of a normal transfer,
            </summary>
        </member>
        <member name="P:CoAP.Net.Exchange.ResponseBlockStatus">
            <summary>
            Gets or sets the status of the blockwise transfer of the response,
            or null in case of a normal transfer,
            </summary>
        </member>
        <member name="P:CoAP.Net.Exchange.Block1ToAck">
            <summary>
            Gets or sets the block option of the last block of a blockwise sent request.
            When the server sends the response, this block option has to be acknowledged.
            </summary>
        </member>
        <member name="P:CoAP.Net.Exchange.Timestamp">
            <summary>
            Gets the time when this exchange was created.
            </summary>
        </member>
        <member name="M:CoAP.Net.Exchange.KeyID.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.Exchange.KeyID.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.Exchange.KeyID.ToString">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.Exchange.KeyToken.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.Exchange.KeyToken.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.Exchange.KeyToken.ToString">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.Exchange.KeyUri.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.Exchange.KeyUri.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Net.Exchange.KeyUri.ToString">
            <inheritdoc/>
        </member>
        <member name="T:CoAP.Net.Origin">
            <summary>
            The origin of an exchange.
            </summary>
        </member>
        <member name="T:CoAP.Util.ArrayEqualityComparer`1">
            <summary>
            <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> for arrays.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:CoAP.Util.ArrayEqualityComparer`1.#ctor">
            <summary>
            Instantiates with default comparer for items in the array.
            </summary>
        </member>
        <member name="M:CoAP.Util.ArrayEqualityComparer`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Instantiates.
            </summary>
            <param name="elementComparer">comparer for items in the array</param>
        </member>
        <member name="M:CoAP.Util.ArrayEqualityComparer`1.Equals(`0[],`0[])">
            <inheritdoc/>
        </member>
        <member name="M:CoAP.Util.ArrayEqualityComparer`1.GetHashCode(`0[])">
            <inheritdoc/>
        </member>
        <member name="P:CoAP.Util.ArrayEqualityComparer`1.Default">
            <summary>
            Gets the default comparer.
            </summary>
        </member>
        <member name="T:CoAP.Stack.ReliabilityLayer">
            <summary>
            The reliability layer
            </summary>
        </member>
        <member name="M:CoAP.Stack.ReliabilityLayer.#ctor(CoAP.ICoapConfig)">
            <summary>
            Constructs a new reliability layer.
            </summary>
        </member>
        <member name="M:CoAP.Stack.ReliabilityLayer.SendRequest(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.Request)">
            <summary>
            // Schedules a retransmission for confirmable messages.
            </summary>
        </member>
        <member name="M:CoAP.Stack.ReliabilityLayer.SendResponse(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.Response)">
            <summary>
            Makes sure that the response type is correct. The response type for a NON
            can be NON or CON. The response type for a CON should either be an ACK
            with a piggy-backed response or, if an empty ACK has already be sent, a
            CON or NON with a separate response.
            </summary>
        </member>
        <member name="M:CoAP.Stack.ReliabilityLayer.ReceiveRequest(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.Request)">
            <summary>
            When we receive a duplicate of a request, we stop it here and do not
            forward it to the upper layer. If the server has already sent a response,
            we send it again. If the request has only been acknowledged (but the ACK
            has gone lost or not reached the client yet), we resent the ACK. If the
            request has neither been responded, acknowledged or rejected yet, the
            server has not yet decided what to do with the request and we cannot do
            anything.
            </summary>
        </member>
        <member name="M:CoAP.Stack.ReliabilityLayer.ReceiveResponse(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.Response)">
            <summary>
            When we receive a Confirmable response, we acknowledge it and it also
            counts as acknowledgment for the request. If the response is a duplicate,
            we stop it here and do not forward it to the upper layer.
            </summary>
        </member>
        <member name="M:CoAP.Stack.ReliabilityLayer.ReceiveEmptyMessage(CoAP.Stack.INextLayer,CoAP.Net.Exchange,CoAP.EmptyMessage)">
            <summary>
            If we receive an ACK or RST, we mark the outgoing request or response
            as acknowledged or rejected respectively and cancel its retransmission.
            </summary>
        </member>
        <member name="T:CoAP.Observe.ObserveNotificationOrderer">
            <summary>
            This class holds the state of an observe relation such
            as the timeout of the last notification and the current number.
            </summary>
        </member>
        <member name="M:CoAP.Observe.ObserveNotificationOrderer.GetNextObserveNumber">
            <summary>
            Gets a new observe option number.
            </summary>
            <returns>a new observe option number</returns>
        </member>
        <member name="P:CoAP.Observe.ObserveNotificationOrderer.Current">
            <summary>
            Gets the current notification number.
            </summary>
        </member>
        <member name="T:CoAP.CoapClient">
            <summary>
            Provides convenient methods for accessing CoAP resources.
            </summary>
        </member>
        <member name="M:CoAP.CoapClient.#ctor">
            <summary>
            Instantiates with default config.
            </summary>
        </member>
        <member name="M:CoAP.CoapClient.#ctor(System.Uri)">
            <summary>
            Instantiates with default config.
            </summary>
            <param name="uri">the Uri of remote resource</param>
        </member>
        <member name="M:CoAP.CoapClient.#ctor(CoAP.ICoapConfig)">
            <summary>
            Instantiates.
            </summary>
            <param name="config">the config</param>
        </member>
        <member name="M:CoAP.CoapClient.#ctor(System.Uri,CoAP.ICoapConfig)">
            <summary>
            Instantiates.
            </summary>
            <param name="uri">the Uri of remote resource</param>
            <param name="config">the config</param>
        </member>
        <member name="M:CoAP.CoapClient.UseCONs">
            <summary>
            Let the client use Confirmable requests.
            </summary>
        </member>
        <member name="M:CoAP.CoapClient.UseNONs">
            <summary>
            Let the client use Non-Confirmable requests.
            </summary>
        </member>
        <member name="M:CoAP.CoapClient.UseEarlyNegotiation(System.Int32)">
            <summary>
            Let the client use early negotiation for the blocksize
            (16, 32, 64, 128, 256, 512, or 1024). Other values will
            be matched to the closest logarithm dualis.
            </summary>
        </member>
        <member name="M:CoAP.CoapClient.UseLateNegotiation">
            <summary>
            Let the client use late negotiation for the block size (default).
            </summary>
        </member>
        <member name="M:CoAP.CoapClient.Ping">
            <summary>
            Performs a CoAP ping.
            </summary>
            <returns>success of the ping</returns>
        </member>
        <member name="M:CoAP.CoapClient.Ping(System.Int32)">
            <summary>
            Performs a CoAP ping and gives up after the given number of milliseconds.
            </summary>
            <param name="timeout">the time to wait for a pong in milliseconds</param>
            <returns>success of the ping</returns>
        </member>
        <member name="M:CoAP.CoapClient.Discover">
            <summary>
            Discovers remote resources.
            </summary>
            <returns>the descoverd <see cref="T:CoAP.WebLink"/> representing remote resources, or null if no response</returns>
        </member>
        <member name="M:CoAP.CoapClient.Discover(System.String)">
            <summary>
            Discovers remote resources.
            </summary>
            <param name="query">the query to filter resources</param>
            <returns>the descoverd <see cref="T:CoAP.WebLink"/> representing remote resources, or null if no response</returns>
        </member>
        <member name="M:CoAP.CoapClient.Get">
            <summary>
            Sends a GET request and blocks until the response is available.
            </summary>
            <returns>the CoAP response</returns>
        </member>
        <member name="M:CoAP.CoapClient.Get(System.Int32)">
            <summary>
            Sends a GET request with the specified Accept option and blocks
            until the response is available.
            </summary>
            <param name="accept">the Accept option</param>
            <returns>the CoAP response</returns>
        </member>
        <member name="M:CoAP.CoapClient.GetAsync(System.Action{CoAP.Response},System.Action{CoAP.CoapClient.FailReason})">
            <summary>
            Sends a GET request asynchronizely.
            </summary>
            <param name="done">the callback when a response arrives</param>
            <param name="fail">the callback when an error occurs</param>
        </member>
        <member name="M:CoAP.CoapClient.GetAsync(System.Int32,System.Action{CoAP.Response},System.Action{CoAP.CoapClient.FailReason})">
            <summary>
            Sends a GET request with the specified Accept option asynchronizely.
            </summary>
            <param name="accept">the Accept option</param>
            <param name="done">the callback when a response arrives</param>
            <param name="fail">the callback when an error occurs</param>
        </member>
        <member name="M:CoAP.CoapClient.Delete">
            <summary>
            Sends a DELETE request and waits for the response.
            </summary>
            <returns>the CoAP response</returns>
        </member>
        <member name="M:CoAP.CoapClient.DeleteAsync(System.Action{CoAP.Response},System.Action{CoAP.CoapClient.FailReason})">
            <summary>
            Sends a DELETE request asynchronizely.
            </summary>
            <param name="done">the callback when a response arrives</param>
            <param name="fail">the callback when an error occurs</param>
        </member>
        <member name="M:CoAP.CoapClient.GetEffectiveEndpoint(CoAP.Request)">
            <summary>
            Gets the effective endpoint that the specified request
            is supposed to be sent over.
            </summary>
        </member>
        <member name="E:CoAP.CoapClient.Respond">
            <summary>
            Occurs when a response has arrived.
            </summary>
        </member>
        <member name="E:CoAP.CoapClient.Error">
            <summary>
            Occurs if an exception is thrown while executing a request.
            </summary>
        </member>
        <member name="P:CoAP.CoapClient.Uri">
            <summary>
            Gets or sets the destination URI of this client.
            </summary>
        </member>
        <member name="P:CoAP.CoapClient.EndPoint">
            <summary>
            Gets or sets the endpoint this client is supposed to use.
            </summary>
        </member>
        <member name="P:CoAP.CoapClient.Timeout">
            <summary>
            Gets or sets the timeout how long synchronous method calls will wait
            until they give up and return anyways. The default value is <see cref="F:System.Threading.Timeout.Infinite"/>.
            </summary>
        </member>
        <member name="T:CoAP.CoapClient.FailReason">
            <summary>
            Provides details about errors.
            </summary>
        </member>
        <member name="F:CoAP.CoapClient.FailReason.Rejected">
            <summary>
            The request has been rejected.
            </summary>
        </member>
        <member name="F:CoAP.CoapClient.FailReason.TimedOut">
            <summary>
            The request has been timed out.
            </summary>
        </member>
        <member name="T:CoAP.CoapClient.ErrorEventArgs">
            <summary>
            Provides event args for errors.
            </summary>
        </member>
        <member name="P:CoAP.CoapClient.ErrorEventArgs.Reason">
            <summary>
            Gets the reason why failed.
            </summary>
        </member>
    </members>
</doc>
